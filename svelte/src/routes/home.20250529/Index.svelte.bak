<script lang="ts">
	import { onMount } from 'svelte';
	import { goto } from '@mateothegreat/svelte5-router';
	import { formatWithCommas } from '$utils/number.util';
	import { ScrollManager, ScrollDirection } from '$lib/utils/ScrollManager';
	import ProfileSidebar from './ProfileSidebar.svelte';
	import Header from './Header.svelte';
	import PlaceDetailPopup from '$lib/components/popup/PlaceDetailPopup.svelte';
	import { detailPopupService } from '$lib/components/popup/DetailPopupService.svelte';
	import Detail from '../place/Detail.svelte';
	import ReviewCard from './components/ReviewCard.svelte';
	import { supabaseReviewService } from '$services/supabase';
	import { reviewService, type ReviewItem } from '$services/review.service';
	import Indicator from '$lib/components/Indicator.svelte';
	import Tabs from '$lib/components/ui/Tabs.svelte';

	// 타입 오류 해결을 위한 타입 선언
	interface ReviewItem {
		id: string;
		business_id: string;
		[key: string]: any;
	}

	// URL 파라미터에서 tabId를 받아오는 부분 추가
	let tabId = $state('');
	
	// props로부터 tabId를 받아옵니다
	let props = $props();
	
	$effect(() => {
		// URL 파라미터에서 tabId 추출
		const pathArray = window.location.pathname.split('/');
		if (pathArray.length > 3 && pathArray[2] === 'tab') {
			tabId = pathArray[3];
		}
	});

	// 브라우저 환경에서만 초기화되는 로컬 상태 변수들
	let wasNavigatingBack = false;
	let lastContentDetailId: string | null = null;
	
	// 브라우저 환경에서만 실행되는 초기화 (SSR 고려)
	if (typeof window !== 'undefined') {
		// 세션스토리지에서 상태 체크 (localStorage 접근 최소화)
		try {
			wasNavigatingBack = sessionStorage.getItem('wasNavigatingBack') === 'true';
			lastContentDetailId = sessionStorage.getItem('currentViewingContentId');
			
			// 사용 후 초기화
			sessionStorage.removeItem('wasNavigatingBack');
			
			if (wasNavigatingBack) {
				console.log('브라우저 뒤로가기 감지: 세션스토리지 플래그 확인됨');
				
				// 마지막으로 본 컨텐츠 ID가 있는지 확인
				if (lastContentDetailId) {
					console.log('마지막으로 본 컨텐츠 ID:', lastContentDetailId);
				}
			}
		} catch (e) {
			console.error('로컬 상태 초기화 오류:', e);
		}
	}

	// 홈 페이지 상태 저장을 위한 객체
	let homeState = $state({
		reviews: [] as ReviewItem[],
		page: 1,
		scrollPosition: 0,
		activeTab: 0,
		type: 'popularity',
		expandedTexts: {} as Record<string, boolean>
	});

	let showNav = $state(true);
	let showSidebar = $state(false);
	let scrollableArea: HTMLDivElement | undefined = $state();
	let y = $state(0);
	let refreshMessage = $state('');
	let isNoMoreData = $state(false);
	// latest,popularity
	let type = $state('popularity');
	
	// 이전 페이지 추적 변수

	// 스크롤 매니저 인스턴스 생성
	const scrollManager = new ScrollManager({
		headerThreshold: 5,
		refreshThreshold: -100,
		debug: false // 개발 중 디버그 모드 활성화
	});
	
	function toggleSidebar(): void {
		console.log('사이드바 토글');
		showSidebar = !showSidebar;
	}
	
	$effect(() => {
		console.log('onMount 실행됨');
		
		// 스크롤 매니저 초기화
		const cleanup = scrollManager.initialize();
		
		// 스크롤 컨테이너 요소 설정
		if (scrollableArea) {
			scrollManager.setContainerElement(scrollableArea);
		}
		
		// 스크롤 이벤트 구독
		const unsubscribeScroll = scrollManager.onScroll((scrollPosition) => {
			y = scrollPosition;
			// 스크롤 위치 homeState에 저장
			homeState.scrollPosition = scrollPosition;
		});
		
		// 위로 스크롤 시 헤더 표시
		const unsubscribeScrollUp = scrollManager.onDirectionChange(
			ScrollDirection.UP,
			() => {
				if (!showNav) {
					showNav = true;
				}
			}
		);
		
		// 아래로 스크롤 시 헤더 숨김
		const unsubscribeScrollDown = scrollManager.onDirectionChange(
			ScrollDirection.DOWN,
			() => {
				if (showNav) {
					showNav = false;
				}
			}
		);
		
		// 새로고침 트리거 이벤트 구독
		const unsubscribeRefresh = scrollManager.onRefreshTriggered((position) => {
			refreshMessage = `새로고침 트리거 (${position}px)`;
			console.log('새로고침 트리거:', position);
			
			// 3초 후 메시지 지우기
			setTimeout(() => {
				refreshMessage = '';
			}, 3000);
		});
		
		// 컴포넌트 정리 함수 반환
		return () => {
			// 컴포넌트가 언마운트될 때 상태 저장
			saveHomeState();
			
			cleanup();
			unsubscribeScroll();
			unsubscribeScrollUp();
			unsubscribeScrollDown();
			unsubscribeRefresh();
		};
	});

	// 상태 관리
	let loading = $state(true);
	let reviews: ReviewItem[] = $state([]);
	let page = $state(1);
	let size = $state(20);
	let expandedTexts = $state<Record<string, boolean>>({});
	let activeTab = $state(0); // 활성 탭 인덱스 추가

	// 탭 정보
	const tabs = [
  { id: 'popularity', label: '인기', desc: '최근 3개월 동안 많은 사람들의 관심을 받은 리뷰를 모아 보여드려요.', emoji: '', view:'mv_place_review_popularity_for_3m_10k' },
  { id: 'hidden_gem', label: '발견', desc: '아직 많이 알려지지 않았지만, 품질 좋은 리뷰로 뽑힌 맛집을 찾아드려요.', emoji: '', view:'mv_place_review_hidden_gem_for_10k' },
//   { id: 'seasonal', label: '시즌', desc: '지금 계절에 딱 어울리는, 최근 2년간 계절별 인기 리뷰를 소개합니다.', emoji: '', view:'mv_place_review_seasonal_for_2y_10k' },
  { id: 'visit_count', label: '단골', desc: '여러 번 방문한 단골들이 남긴 신뢰도 높은 리뷰만 모아서 보여드려요.', emoji: '', view:'mv_place_review_regular_customer_for_10k' },
  { id: 'latest', label: '최신', desc: '가장 최근에 등록된 따끈한 리뷰들을 모았어요. 최신 트렌드를 놓치지 마세요.', emoji: '', view:'mv_place_review_popularity_for_3m_10k' },
  { id: 'my_liked', label: '좋아요', desc: '내가 "좋아요"를 누른 리뷰만 모아서 한 번에 볼 수 있도록 보여드려요.', emoji: '', view:'mv_place_review_my_liked_for_10k' },
]

	// 홈 페이지 상태 저장 함수
	function saveHomeState() {
		homeState = {
			reviews,
			page,
			scrollPosition: y,
			activeTab,
			type,
			expandedTexts
		};
		
		console.log('홈 페이지 상태 저장');
		
		try {
			// 상태 저장 시 타임스탬프와 함께 저장 (나중에 상태의 신선도 확인용)
			const stateWithMeta = {
				data: homeState,
				timestamp: new Date().getTime(),
				source: 'homePageState'
			};
			
			// 세션스토리지만 사용 (모바일 성능 최적화)
			sessionStorage.setItem('homeUIState', JSON.stringify(stateWithMeta));
			
			console.log('홈 상태 저장 완료');
		} catch (error) {
			console.error('상태 저장 실패:', error);
		}
	}
	
	// 홈 페이지 상태 복원 함수
	function restoreHomeState() {
		try {
			// 세션스토리지에서만 시도 (localStorage 접근 제거)
			const savedStateJson = sessionStorage.getItem('homeUIState');
			
			if (!savedStateJson) {
				console.log('저장된 상태 없음: 새로운 데이터 로드 필요');
				return false;
			}
			
			console.log('저장된 상태 발견');
			
			const savedStateMeta = JSON.parse(savedStateJson);
			const parsedState = savedStateMeta.data;
			const timestamp = savedStateMeta.timestamp;
			
			// 타임스탬프 확인 (5분 이상 지난 데이터는 신선하지 않은 것으로 간주 - 시간 단축)
			const now = new Date().getTime();
			const isStale = now - timestamp > 5 * 60 * 1000; // 5분
			
			if (isStale) {
				console.log('저장된 상태가 오래됨 (5분 초과)');
				sessionStorage.removeItem('homeUIState');
				return false;
			}
			
			console.log('저장된 상태 복원 중');
			
			// 필요한 상태들 복원
			reviews = parsedState.reviews || [];
			page = parsedState.page || 1;
			activeTab = parsedState.activeTab ?? 0;
			type = parsedState.type || 'popularity';
			expandedTexts = parsedState.expandedTexts || {};
			
			// 스크롤 위치 복원
			if (scrollableArea && parsedState.scrollPosition) {
				console.log('스크롤 위치 복원 예정:', parsedState.scrollPosition);
				// RAF를 사용하여 DOM 업데이트 후 스크롤 적용 (setTimeout 추가로 안정성 향상)
				setTimeout(() => {
					requestAnimationFrame(() => {
						if (scrollableArea) {
							console.log('스크롤 위치 복원 실행');
							scrollableArea.scrollTop = parsedState.scrollPosition;
						}
					});
				}, 0);
			}
			
			// 복원 후 상태 제거 (중요: 일회성 사용 보장)
			sessionStorage.removeItem('homeUIState');
			console.log('저장된 상태 복원 및 삭제 완료');
			
			return true;
		} catch (error) {
			console.error('상태 복원 실패:', error);
			sessionStorage.removeItem('homeUIState');
		}
		
		return false;
	}

	// 탭 변경 함수
	function handleTabChange(index: number) {
		activeTab = index;
		type = tabs[activeTab].id;
		page = 1;
		reviews = [];
		isNoMoreData = false;
		loadReviews(page, size, type);
		
		// URL 변경
		goto(`/home/tab/${tabs[activeTab].id}`, { replace: true });
		
		// 스크롤을 맨 위로 이동
		scrollManager.scrollToTop('auto');
	}

	// 날짜 포맷팅 함수
	function formatDate(dateString: string): string {
		if (!dateString) return '';

		const year = dateString.substring(0, 4);
		const month = dateString.substring(4, 6);
		const day = dateString.substring(6, 8);

		return `${year}.${month}.${day}`;
	}

	// 텍스트 자르기 함수

	// 텍스트 확장/축소 토글
	function toggleExpandText(reviewId: string): void {
		expandedTexts[reviewId] = !expandedTexts[reviewId];
		expandedTexts = { ...expandedTexts };
	}

	// 리뷰 데이터 로드
	async function loadReviews(currentPage: number = 1, pageSize: number = 20, type: string = 'latest'): Promise<void> {
		try {
			loading = true;
			// Supabase 서비스를 사용하여 리뷰 데이터 가져오기
			const response = await reviewService.getReviewList2({
				page: currentPage,
				size: pageSize,
				type: type,
			});
			
			if (response && response.result && Array.isArray(response.result.rows)) {
				reviews = response.result.rows;
				isNoMoreData = response.result.rows.length !== size;
				console.log(`isNoMoreData: ${isNoMoreData}`);

				// 초기 expandedTexts 세팅
				const initialExpandedState: Record<string, boolean> = {};
				reviews.forEach((review: ReviewItem) => {
					initialExpandedState[review.id] = false;
				});
				expandedTexts = initialExpandedState;
			}
		} catch (error) {
			console.error('리뷰 데이터 로드 실패:', error);
		} finally {
			loading = false;
		}
	}

	// 카테고리에 맞는 배경색 반환

	// 주소를 태그로 변환


	// 장소 상세 페이지로 이동 (팝업 사용 대신 URL 이동 방식으로 변경)
	function goToPlaceDetail(businessId: string): void {
		console.log('장소 상세 페이지로 이동:', businessId);
		
		// 현재 홈 페이지 상태 저장 (상세 페이지로 이동 전)
		saveHomeState();
		
		// 현재 보고 있는 컨텐츠 ID 저장
		try {
			localStorage.setItem('currentViewingContentId', businessId);
			console.log('현재 보는 컨텐츠 ID 저장:', businessId);
		} catch (e) {
			console.error('ID 저장 오류:', e);
		}
		
		// 상태 정보 준비
		const state = { 
			fromHome: true, 
			hasHomeState: true,
			businessId,
			savedAt: new Date().getTime()
		};
		
		// SPA 라우터 사용하여 이동 (state 옵션 사용)
		try {
			goto(`/place/${businessId}`, { state });
			console.log('라우터로 이동 완료, 상태 정보:', state);
		} catch (e) {
			// 오류 발생 시 대체 방법으로 이동
			console.error('라우터 사용 오류:', e);
			location.href = `/place/${businessId}`;
		}
	}

	// 네이버 장소 링크로 이동

	// 추가 리뷰 데이터 로드
	async function loadMoreReviewsData(): Promise<void> {
		try {
			loading = true;
			const response = await reviewService.getReviewList2({
				page: page,
				size: size,
				type: type,
			});

			if (response && response.result && Array.isArray(response.result.rows)) {
				const newReviews = response.result.rows;

				// 새 리뷰에 대한 expandedTexts 세팅
				const newExpandedState: Record<string, boolean> = { ...expandedTexts };
				newReviews.forEach((review: ReviewItem) => {
					newExpandedState[review.id] = false;
				});
				expandedTexts = newExpandedState;

				// 리뷰 데이터 병합
				reviews = [...reviews, ...newReviews];
				isNoMoreData = newReviews.length !== size;
			}
		} catch (error) {
			console.error('추가 리뷰 데이터 로드 실패:', error);
		} finally {
			loading = false;
		}
	}

	// 더 많은 리뷰 로드
	function loadMoreReviews(): void {
		if (loading || isNoMoreData) return;

		page += 1;
		loadMoreReviewsData();
	}

	// 스크롤 이벤트 핸들러
	let isScrollListenerAdded = false;

	function handleScroll(): void {
		if (loading || isNoMoreData) return;

		if (!scrollableArea) return;

		const { scrollTop, scrollHeight, clientHeight } = scrollableArea;

		// 스크롤이 하단에 가까워지면 추가 데이터 로드
		if (scrollTop + clientHeight >= scrollHeight - 300) {
			loadMoreReviews();
		}
	}

	$effect(() => {
		if (scrollableArea && !isScrollListenerAdded) {
			scrollableArea.addEventListener('scroll', handleScroll);
			isScrollListenerAdded = true;
		}
	});

	// 네비게이션 타입 감지 함수
	function detectNavigationType(): { isBackNavigation: boolean; source: string; isDirectNavigation: boolean } {
		// 브라우저 뒤로가기 감지를 위한 여러 기법 적용
		try {
			// 1. Performance API 활용 (가장 신뢰할 수 있는 방법)
			const navigationEntries = window.performance?.getEntriesByType?.('navigation') || [];
			const navigationEntry = navigationEntries[0] as PerformanceNavigationTiming;
			const navigationType = navigationEntry?.type || 'unknown';
			const isBackForward = navigationType === 'back_forward';
			
			// 2. localStorage 플래그 확인 (다른 페이지에서 설정됨)
			const localBackFlag = wasNavigatingBack;
			
			// 3. 현재 history.state 확인
			const currentState = history.state || {};
			const historyBackFlag = currentState.isBackNavigation === true || 
			                        (currentState.fromContentDetail === true) ||
			                        (currentState.fromPlaceDetail === true);
			
			// history.state에서 추가 정보 확인
			const fromDetailPage = currentState.fromContentDetail || currentState.fromPlaceDetail;
			const stateBusinessId = currentState.businessId;
			
			// 4. sessionStorage 플래그 확인
			const sessionBackFlag = sessionStorage.getItem('isBackNavigation') === 'true';
			sessionStorage.removeItem('isBackNavigation');
			
			// 5. Referrer 확인 (이전 페이지 URL 체크)
			const referrer = document.referrer || '';
			const isFromContentDetail = referrer.includes('/place/') || referrer.includes('/content/');
			
			// 6. 새로고침 감지
			const isReload = navigationType === 'reload';
			
			// 7. 직접 접근(URL 입력, 메뉴를 통한 접근) 감지
			const isDirectNavigation = navigationType === 'navigate' && !isFromContentDetail;
			
			// 로깅
			console.log('네비게이션 타입 감지 결과:', {
				isBackForward,
				localBackFlag,
				historyBackFlag,
				sessionBackFlag,
				isFromContentDetail,
				referrer,
				navigationType,
				isReload,
				isDirectNavigation,
				historyState: currentState,
				stateBusinessId
			});
			
			// 각 감지 방법의 결과 종합
			const isBackNavigation = isBackForward || localBackFlag || historyBackFlag || 
									sessionBackFlag || isFromContentDetail;
			
			// 뒤로가기의 출처 식별
			let source = 'unknown';
			if (isBackForward) source = 'performance_api';
			else if (localBackFlag) source = 'localStorage';
			else if (historyBackFlag) source = 'history_state';
			else if (sessionBackFlag) source = 'sessionStorage';
			else if (isFromContentDetail) source = 'referrer';
			else if (isReload) source = 'reload';
			else if (isDirectNavigation) source = 'direct';
			
			// 뒤로가기로 확인되었고 state에 상세 정보가 있는 경우
			if (isBackNavigation && fromDetailPage && stateBusinessId) {
				console.log('상세 페이지에서 뒤로가기로 돌아옴, 컨텐츠 ID:', stateBusinessId);
				// 필요시 여기에 추가 처리 코드 작성
			}
			
			return { isBackNavigation, source, isDirectNavigation };
		} catch (err) {
			console.error('네비게이션 타입 감지 오류:', err);
			return { isBackNavigation: false, source: 'error', isDirectNavigation: true };
		}
	}

	// 컴포넌트 마운트 시 실행
	onMount(() => {
		console.log('onMount: 홈 페이지 로드 시작');
		
		// URL 파라미터에서 탭 ID 읽기
		const urlParams = new URLSearchParams(window.location.search);
		const pathArray = window.location.pathname.split('/');
		const tabIdFromUrl = pathArray.length > 3 && pathArray[2] === 'tab' ? pathArray[3] : null;
		
		// URL의 탭 ID가 있으면 해당 탭으로 설정
		if (tabIdFromUrl) {
			console.log('URL 파라미터에서 탭 ID 감지:', tabIdFromUrl);
			const tabIndex = tabs.findIndex(tab => tab.id === tabIdFromUrl);
			if (tabIndex !== -1) {
				activeTab = tabIndex;
				type = tabs[activeTab].id;
				console.log('탭 인덱스를 URL 파라미터로 설정:', activeTab);
			}
		}
		
		// 네비게이션 타입 감지
		const { isBackNavigation, source, isDirectNavigation } = detectNavigationType();
		console.log(`네비게이션 타입: ${isBackNavigation ? '뒤로가기' : '일반 접근'} (출처: ${source})`);
		
		// 스크롤 매니저 초기화
		const cleanup = scrollManager.initialize();
		
		// 스크롤 컨테이너 요소 설정
		if (scrollableArea) {
			scrollManager.setContainerElement(scrollableArea);
		}
		
		// 스크롤 이벤트 구독
		const unsubscribeScroll = scrollManager.onScroll((scrollPosition) => {
			y = scrollPosition;
			// 스크롤 위치 homeState에 저장
			homeState.scrollPosition = scrollPosition;
		});
		
		// 위로 스크롤 시 헤더 표시
		const unsubscribeScrollUp = scrollManager.onDirectionChange(
			ScrollDirection.UP,
			() => {
				if (!showNav) {
					showNav = true;
				}
			}
		);
		
		// 아래로 스크롤 시 헤더 숨김
		const unsubscribeScrollDown = scrollManager.onDirectionChange(
			ScrollDirection.DOWN,
			() => {
				if (showNav) {
					showNav = false;
				}
			}
		);
		
		// 새로고침 트리거 이벤트 구독
		const unsubscribeRefresh = scrollManager.onRefreshTriggered((position) => {
			refreshMessage = `새로고침 트리거 (${position}px)`;
			console.log('새로고침 트리거:', position);
			
			// 3초 후 메시지 지우기
			setTimeout(() => {
				refreshMessage = '';
			}, 3000);
		});
		
		// 컴포넌트 정리 함수 반환
		return () => {
			// 컴포넌트가 언마운트될 때 상태 저장
			saveHomeState();
			
			cleanup();
			unsubscribeScroll();
			unsubscribeScrollUp();
			unsubscribeScrollDown();
			unsubscribeRefresh();
		};
	});
});
</script>

<script lang="ts">
	import { onMount } from 'svelte';
	import { goto } from '@mateothegreat/svelte5-router';
	import { formatWithCommas } from '$utils/number.util';
	import { ScrollManager, ScrollDirection } from '$lib/utils/ScrollManager';
	import ProfileSidebar from './ProfileSidebar.svelte';
	import Header from './Header.svelte';
	import PlaceDetailPopup from '$lib/components/popup/PlaceDetailPopup.svelte';
	import { detailPopupService } from '$lib/components/popup/DetailPopupService.svelte';
	import Detail from '../place/Detail.svelte';
	import ReviewCard from './components/ReviewCard.svelte';
	import { supabaseReviewService } from '$services/supabase';
	import { reviewService, type ReviewItem } from '$services/review.service';
	import Indicator from '$lib/components/Indicator.svelte';
	import Tabs from '$lib/components/ui/Tabs.svelte';

	// 타입 오류 해결을 위한 타입 선언
	interface ReviewItem {
		id: string;
		business_id: string;
		[key: string]: any;
	}

	// URL 파라미터에서 tabId를 받아오는 부분 추가
	let tabId = $state('');
	
	// props로부터 tabId를 받아옵니다
	let props = $props();
	
	$effect(() => {
		// URL 파라미터에서 tabId 추출
		const pathArray = window.location.pathname.split('/');
		if (pathArray.length > 3 && pathArray[2] === 'tab') {
			tabId = pathArray[3];
		}
	});

	// 브라우저 환경에서만 초기화되는 로컬 상태 변수들
	let wasNavigatingBack = false;
	let lastContentDetailId: string | null = null;
	
	// 브라우저 환경에서만 실행되는 초기화 (SSR 고려)
	if (typeof window !== 'undefined') {
		// 세션스토리지에서 상태 체크 (localStorage 접근 최소화)
		try {
			wasNavigatingBack = sessionStorage.getItem('wasNavigatingBack') === 'true';
			lastContentDetailId = sessionStorage.getItem('currentViewingContentId');
			
			// 사용 후 초기화
			sessionStorage.removeItem('wasNavigatingBack');
			
			if (wasNavigatingBack) {
				console.log('브라우저 뒤로가기 감지: 세션스토리지 플래그 확인됨');
				
				// 마지막으로 본 컨텐츠 ID가 있는지 확인
				if (lastContentDetailId) {
					console.log('마지막으로 본 컨텐츠 ID:', lastContentDetailId);
				}
			}
		} catch (e) {
			console.error('로컬 상태 초기화 오류:', e);
		}
	}

	// 홈 페이지 상태 저장을 위한 객체
	let homeState = $state({
		reviews: [] as ReviewItem[],
		page: 1,
		scrollPosition: 0,
		activeTab: 0,
		type: 'popularity',
		expandedTexts: {} as Record<string, boolean>
	});

	let showNav = $state(true);
	let showSidebar = $state(false);
	let scrollableArea: HTMLDivElement | undefined = $state();
	let y = $state(0);
	let refreshMessage = $state('');
	let isNoMoreData = $state(false);
	// latest,popularity
	let type = $state('popularity');
	
	// 이전 페이지 추적 변수

	// 스크롤 매니저 인스턴스 생성
	const scrollManager = new ScrollManager({
		headerThreshold: 5,
		refreshThreshold: -100,
		debug: false // 개발 중 디버그 모드 활성화
	});
	
	function toggleSidebar(): void {
		console.log('사이드바 토글');
		showSidebar = !showSidebar;
	}
	
	$effect(() => {
		console.log('onMount 실행됨');
		
		// 스크롤 매니저 초기화
		const cleanup = scrollManager.initialize();
		
		// 스크롤 컨테이너 요소 설정
		if (scrollableArea) {
			scrollManager.setContainerElement(scrollableArea);
		}
		
		// 스크롤 이벤트 구독
		const unsubscribeScroll = scrollManager.onScroll((scrollPosition) => {
			y = scrollPosition;
			// 스크롤 위치 homeState에 저장
			homeState.scrollPosition = scrollPosition;
		});
		
		// 위로 스크롤 시 헤더 표시
		const unsubscribeScrollUp = scrollManager.onDirectionChange(
			ScrollDirection.UP,
			() => {
				if (!showNav) {
					showNav = true;
				}
			}
		);
		
		// 아래로 스크롤 시 헤더 숨김
		const unsubscribeScrollDown = scrollManager.onDirectionChange(
			ScrollDirection.DOWN,
			() => {
				if (showNav) {
					showNav = false;
				}
			}
		);
		
		// 새로고침 트리거 이벤트 구독
		const unsubscribeRefresh = scrollManager.onRefreshTriggered((position) => {
			refreshMessage = `새로고침 트리거 (${position}px)`;
			console.log('새로고침 트리거:', position);
			
			// 3초 후 메시지 지우기
			setTimeout(() => {
				refreshMessage = '';
			}, 3000);
		});
		
		// 컴포넌트 정리 함수 반환
		return () => {
			// 컴포넌트가 언마운트될 때 상태 저장
			saveHomeState();
			
			cleanup();
			unsubscribeScroll();
			unsubscribeScrollUp();
			unsubscribeScrollDown();
			unsubscribeRefresh();
		};
	});

	// 상태 관리
	let loading = $state(true);
	let reviews: ReviewItem[] = $state([]);
	let page = $state(1);
	let size = $state(20);
	let expandedTexts = $state<Record<string, boolean>>({});
	let activeTab = $state(0); // 활성 탭 인덱스 추가

	// 탭 정보
	const tabs = [
  { id: 'popularity', label: '인기', desc: '최근 3개월 동안 많은 사람들의 관심을 받은 리뷰를 모아 보여드려요.', emoji: '', view:'mv_place_review_popularity_for_3m_10k' },
  { id: 'hidden_gem', label: '발견', desc: '아직 많이 알려지지 않았지만, 품질 좋은 리뷰로 뽑힌 맛집을 찾아드려요.', emoji: '', view:'mv_place_review_hidden_gem_for_10k' },
//   { id: 'seasonal', label: '시즌', desc: '지금 계절에 딱 어울리는, 최근 2년간 계절별 인기 리뷰를 소개합니다.', emoji: '', view:'mv_place_review_seasonal_for_2y_10k' },
  { id: 'visit_count', label: '단골', desc: '여러 번 방문한 단골들이 남긴 신뢰도 높은 리뷰만 모아서 보여드려요.', emoji: '', view:'mv_place_review_regular_customer_for_10k' },
  { id: 'latest', label: '최신', desc: '가장 최근에 등록된 따끈한 리뷰들을 모았어요. 최신 트렌드를 놓치지 마세요.', emoji: '', view:'mv_place_review_popularity_for_3m_10k' },
  { id: 'my_liked', label: '좋아요', desc: '내가 "좋아요"를 누른 리뷰만 모아서 한 번에 볼 수 있도록 보여드려요.', emoji: '', view:'mv_place_review_my_liked_for_10k' },
]

	// 홈 페이지 상태 저장 함수
	function saveHomeState() {
		homeState = {
			reviews,
			page,
			scrollPosition: y,
			activeTab,
			type,
			expandedTexts
		};
		
		console.log('홈 페이지 상태 저장');
		
		try {
			// 상태 저장 시 타임스탬프와 함께 저장 (나중에 상태의 신선도 확인용)
			const stateWithMeta = {
				data: homeState,
				timestamp: new Date().getTime(),
				source: 'homePageState'
			};
			
			// 세션스토리지만 사용 (모바일 성능 최적화)
			sessionStorage.setItem('homeUIState', JSON.stringify(stateWithMeta));
			
			console.log('홈 상태 저장 완료');
		} catch (error) {
			console.error('상태 저장 실패:', error);
		}
	}
	
	// 홈 페이지 상태 복원 함수
	function restoreHomeState() {
		try {
			// 세션스토리지에서만 시도 (localStorage 접근 제거)
			const savedStateJson = sessionStorage.getItem('homeUIState');
			
			if (!savedStateJson) {
				console.log('저장된 상태 없음: 새로운 데이터 로드 필요');
				return false;
			}
			
			console.log('저장된 상태 발견');
			
			const savedStateMeta = JSON.parse(savedStateJson);
			const parsedState = savedStateMeta.data;
			const timestamp = savedStateMeta.timestamp;
			
			// 타임스탬프 확인 (5분 이상 지난 데이터는 신선하지 않은 것으로 간주 - 시간 단축)
			const now = new Date().getTime();
			const isStale = now - timestamp > 5 * 60 * 1000; // 5분
			
			if (isStale) {
				console.log('저장된 상태가 오래됨 (5분 초과)');
				sessionStorage.removeItem('homeUIState');
				return false;
			}
			
			console.log('저장된 상태 복원 중');
			
			// 필요한 상태들 복원
			reviews = parsedState.reviews || [];
			page = parsedState.page || 1;
			activeTab = parsedState.activeTab ?? 0;
			type = parsedState.type || 'popularity';
			expandedTexts = parsedState.expandedTexts || {};
			
			// 스크롤 위치 복원
			if (scrollableArea && parsedState.scrollPosition) {
				console.log('스크롤 위치 복원 예정:', parsedState.scrollPosition);
				// RAF를 사용하여 DOM 업데이트 후 스크롤 적용 (setTimeout 추가로 안정성 향상)
				setTimeout(() => {
					requestAnimationFrame(() => {
						if (scrollableArea) {
							console.log('스크롤 위치 복원 실행');
							scrollableArea.scrollTop = parsedState.scrollPosition;
						}
					});
				}, 0);
			}
			
			// 복원 후 상태 제거 (중요: 일회성 사용 보장)
			sessionStorage.removeItem('homeUIState');
			console.log('저장된 상태 복원 및 삭제 완료');
			
			return true;
		} catch (error) {
			console.error('상태 복원 실패:', error);
			sessionStorage.removeItem('homeUIState');
		}
		
		return false;
	}

	// 탭 변경 함수
	function handleTabChange(index: number) {
		activeTab = index;
		type = tabs[activeTab].id;
		page = 1;
		reviews = [];
		isNoMoreData = false;
		loadReviews(page, size, type);
		
		// URL 변경
		goto(`/home/tab/${tabs[activeTab].id}`, { replace: true });
		
		// 스크롤을 맨 위로 이동
		scrollManager.scrollToTop('auto');
	}

	// 날짜 포맷팅 함수
	function formatDate(dateString: string): string {
		if (!dateString) return '';

		const year = dateString.substring(0, 4);
		const month = dateString.substring(4, 6);
		const day = dateString.substring(6, 8);

		return `${year}.${month}.${day}`;
	}

	// 텍스트 자르기 함수

	// 텍스트 확장/축소 토글
	function toggleExpandText(reviewId: string): void {
		expandedTexts[reviewId] = !expandedTexts[reviewId];
		expandedTexts = { ...expandedTexts };
	}

	// 리뷰 데이터 로드
	async function loadReviews(currentPage: number = 1, pageSize: number = 20, type: string = 'latest'): Promise<void> {
		try {
			loading = true;
			// Supabase 서비스를 사용하여 리뷰 데이터 가져오기
			const response = await reviewService.getReviewList2({
				page: currentPage,
				size: pageSize,
				type: type,
			});
			
			if (response && response.result && Array.isArray(response.result.rows)) {
				reviews = response.result.rows;
				isNoMoreData = response.result.rows.length !== size;
				console.log(`isNoMoreData: ${isNoMoreData}`);

				// 초기 expandedTexts 세팅
				const initialExpandedState: Record<string, boolean> = {};
				reviews.forEach((review: ReviewItem) => {
					initialExpandedState[review.id] = false;
				});
				expandedTexts = initialExpandedState;
			}
		} catch (error) {
			console.error('리뷰 데이터 로드 실패:', error);
		} finally {
			loading = false;
		}
	}

	// 카테고리에 맞는 배경색 반환

	// 주소를 태그로 변환


	// 장소 상세 페이지로 이동 (팝업 사용 대신 URL 이동 방식으로 변경)
	function goToPlaceDetail(businessId: string): void {
		console.log('장소 상세 페이지로 이동:', businessId);
		
		// 현재 홈 페이지 상태 저장 (상세 페이지로 이동 전)
		saveHomeState();
		
		// 현재 보고 있는 컨텐츠 ID 저장
		try {
			localStorage.setItem('currentViewingContentId', businessId);
			console.log('현재 보는 컨텐츠 ID 저장:', businessId);
		} catch (e) {
			console.error('ID 저장 오류:', e);
		}
		
		// 상태 정보 준비
		const state = { 
			fromHome: true, 
			hasHomeState: true,
			businessId,
			savedAt: new Date().getTime()
		};
		
		// SPA 라우터 사용하여 이동 (state 옵션 사용)
		try {
			goto(`/place/${businessId}`, { state });
			console.log('라우터로 이동 완료, 상태 정보:', state);
		} catch (e) {
			// 오류 발생 시 대체 방법으로 이동
			console.error('라우터 사용 오류:', e);
			location.href = `/place/${businessId}`;
		}
	}

	// 네이버 장소 링크로 이동

	// 추가 리뷰 데이터 로드
	async function loadMoreReviewsData(): Promise<void> {
		try {
			loading = true;
			const response = await reviewService.getReviewList2({
				page: page,
				size: size,
				type: type,
			});

			if (response && response.result && Array.isArray(response.result.rows)) {
				const newReviews = response.result.rows;

				// 새 리뷰에 대한 expandedTexts 세팅
				const newExpandedState: Record<string, boolean> = { ...expandedTexts };
				newReviews.forEach((review: ReviewItem) => {
					newExpandedState[review.id] = false;
				});
				expandedTexts = newExpandedState;

				// 리뷰 데이터 병합
				reviews = [...reviews, ...newReviews];
				isNoMoreData = newReviews.length !== size;
			}
		} catch (error) {
			console.error('추가 리뷰 데이터 로드 실패:', error);
		} finally {
			loading = false;
		}
	}

	// 더 많은 리뷰 로드
	function loadMoreReviews(): void {
		if (loading || isNoMoreData) return;

		page += 1;
		loadMoreReviewsData();
	}

	// 스크롤 이벤트 핸들러
	let isScrollListenerAdded = false;

	function handleScroll(): void {
		if (loading || isNoMoreData) return;

		if (!scrollableArea) return;

		const { scrollTop, scrollHeight, clientHeight } = scrollableArea;

		// 스크롤이 하단에 가까워지면 추가 데이터 로드
		if (scrollTop + clientHeight >= scrollHeight - 300) {
			loadMoreReviews();
		}
	}

	$effect(() => {
		if (scrollableArea && !isScrollListenerAdded) {
			scrollableArea.addEventListener('scroll', handleScroll);
			isScrollListenerAdded = true;
		}
	});

	// 네비게이션 타입 감지 함수
	function detectNavigationType(): { isBackNavigation: boolean; source: string; isDirectNavigation: boolean } {
		// 브라우저 뒤로가기 감지를 위한 여러 기법 적용
		try {
			// 1. Performance API 활용 (가장 신뢰할 수 있는 방법)
			const navigationEntries = window.performance?.getEntriesByType?.('navigation') || [];
			const navigationEntry = navigationEntries[0] as PerformanceNavigationTiming;
			const navigationType = navigationEntry?.type || 'unknown';
			const isBackForward = navigationType === 'back_forward';
			
			// 2. localStorage 플래그 확인 (다른 페이지에서 설정됨)
			const localBackFlag = wasNavigatingBack;
			
			// 3. 현재 history.state 확인
			const currentState = history.state || {};
			const historyBackFlag = currentState.isBackNavigation === true || 
			                        (currentState.fromContentDetail === true) ||
			                        (currentState.fromPlaceDetail === true);
			
			// history.state에서 추가 정보 확인
			const fromDetailPage = currentState.fromContentDetail || currentState.fromPlaceDetail;
			const stateBusinessId = currentState.businessId;
			
			// 4. sessionStorage 플래그 확인
			const sessionBackFlag = sessionStorage.getItem('isBackNavigation') === 'true';
			sessionStorage.removeItem('isBackNavigation');
			
			// 5. Referrer 확인 (이전 페이지 URL 체크)
			const referrer = document.referrer || '';
			const isFromContentDetail = referrer.includes('/place/') || referrer.includes('/content/');
			
			// 6. 새로고침 감지
			const isReload = navigationType === 'reload';
			
			// 7. 직접 접근(URL 입력, 메뉴를 통한 접근) 감지
			const isDirectNavigation = navigationType === 'navigate' && !isFromContentDetail;
			
			// 로깅
			console.log('네비게이션 타입 감지 결과:', {
				isBackForward,
				localBackFlag,
				historyBackFlag,
				sessionBackFlag,
				isFromContentDetail,
				referrer,
				navigationType,
				isReload,
				isDirectNavigation,
				historyState: currentState,
				stateBusinessId
			});
			
			// 각 감지 방법의 결과 종합
			const isBackNavigation = isBackForward || localBackFlag || historyBackFlag || 
									sessionBackFlag || isFromContentDetail;
			
			// 뒤로가기의 출처 식별
			let source = 'unknown';
			if (isBackForward) source = 'performance_api';
			else if (localBackFlag) source = 'localStorage';
			else if (historyBackFlag) source = 'history_state';
			else if (sessionBackFlag) source = 'sessionStorage';
			else if (isFromContentDetail) source = 'referrer';
			else if (isReload) source = 'reload';
			else if (isDirectNavigation) source = 'direct';
			
			// 뒤로가기로 확인되었고 state에 상세 정보가 있는 경우
			if (isBackNavigation && fromDetailPage && stateBusinessId) {
				console.log('상세 페이지에서 뒤로가기로 돌아옴, 컨텐츠 ID:', stateBusinessId);
				// 필요시 여기에 추가 처리 코드 작성
			}
			
			return { isBackNavigation, source, isDirectNavigation };
		} catch (err) {
			console.error('네비게이션 타입 감지 오류:', err);
			return { isBackNavigation: false, source: 'error', isDirectNavigation: true };
		}
	}

	// 컴포넌트 마운트 시 실행
	onMount(() => {
		console.log('onMount: 홈 페이지 로드 시작');
		
		// URL 파라미터에서 탭 ID 읽기
		const urlParams = new URLSearchParams(window.location.search);
		const pathArray = window.location.pathname.split('/');
		const tabIdFromUrl = pathArray.length > 3 && pathArray[2] === 'tab' ? pathArray[3] : null;
		
		// URL의 탭 ID가 있으면 해당 탭으로 설정
		if (tabIdFromUrl) {
			console.log('URL 파라미터에서 탭 ID 감지:', tabIdFromUrl);
			const tabIndex = tabs.findIndex(tab => tab.id === tabIdFromUrl);
			if (tabIndex !== -1) {
				activeTab = tabIndex;
				type = tabs[activeTab].id;
				console.log('탭 인덱스를 URL 파라미터로 설정:', activeTab);
			}
		}
		
		// 네비게이션 타입 감지
		const { isBackNavigation, source, isDirectNavigation } = detectNavigationType();
		console.log(`네비게이션 타입: ${isBackNavigation ? '뒤로가기' : '일반 접근'} (출처: ${source})`);
		
		// 스크롤 매니저 초기화
		const cleanup = scrollManager.initialize();
		
		// 스크롤 컨테이너 요소 설정
		if (scrollableArea) {
			scrollManager.setContainerElement(scrollableArea);
		}
		
		// 스크롤 이벤트 구독
		const unsubscribeScroll = scrollManager.onScroll((scrollPosition) => {
			y = scrollPosition;
			// 스크롤 위치 homeState에 저장
			homeState.scrollPosition = scrollPosition;
		});
		
		// 위로 스크롤 시 헤더 표시
		const unsubscribeScrollUp = scrollManager.onDirectionChange(
			ScrollDirection.UP,
			() => {
				if (!showNav) {
					showNav = true;
				}
			}
		);
		
		// 아래로 스크롤 시 헤더 숨김
		const unsubscribeScrollDown = scrollManager.onDirectionChange(
			ScrollDirection.DOWN,
			() => {
				if (showNav) {
					showNav = false;
				}
			}
		);
		
		// 새로고침 트리거 이벤트 구독
		const unsubscribeRefresh = scrollManager.onRefreshTriggered((position) => {
			refreshMessage = `새로고침 트리거 (${position}px)`;
			console.log('새로고침 트리거:', position);
			
			// 3초 후 메시지 지우기
			setTimeout(() => {
				refreshMessage = '';
			}, 3000);
		});
		
		// 컴포넌트 정리 함수 반환
		return () => {
			// 컴포넌트가 언마운트될 때 상태 저장
			saveHomeState();
			
			cleanup();
			unsubscribeScroll();
			unsubscribeScrollUp();
			unsubscribeScrollDown();
			unsubscribeRefresh();
		};
	});
});
</script>

<script lang="ts">
	import { onMount } from 'svelte';
	import { goto } from '@mateothegreat/svelte5-router';
	import { formatWithCommas } from '$utils/number.util';
	import { ScrollManager, ScrollDirection } from '$lib/utils/ScrollManager';
	import ProfileSidebar from './ProfileSidebar.svelte';
	import Header from './Header.svelte';
	import PlaceDetailPopup from '$lib/components/popup/PlaceDetailPopup.svelte';
	import { detailPopupService } from '$lib/components/popup/DetailPopupService.svelte';
	import Detail from '../place/Detail.svelte';
	import ReviewCard from './components/ReviewCard.svelte';
	import { supabaseReviewService } from '$services/supabase';
	import { reviewService, type ReviewItem } from '$services/review.service';
	import Indicator from '$lib/components/Indicator.svelte';
	import Tabs from '$lib/components/ui/Tabs.svelte';

	// 타입 오류 해결을 위한 타입 선언
	interface ReviewItem {
		id: string;
		business_id: string;
		[key: string]: any;
	}

	// URL 파라미터에서 tabId를 받아오는 부분 추가
	let tabId = $state('');
	
	// props로부터 tabId를 받아옵니다
	let props = $props();
	
	$effect(() => {
		// URL 파라미터에서 tabId 추출
		const pathArray = window.location.pathname.split('/');
		if (pathArray.length > 3 && pathArray[2] === 'tab') {
			tabId = pathArray[3];
		}
	});

	// 브라우저 환경에서만 초기화되는 로컬 상태 변수들
	let wasNavigatingBack = false;
	let lastContentDetailId: string | null = null;
	
	// 브라우저 환경에서만 실행되는 초기화 (SSR 고려)
	if (typeof window !== 'undefined') {
		// 세션스토리지에서 상태 체크 (localStorage 접근 최소화)
		try {
			wasNavigatingBack = sessionStorage.getItem('wasNavigatingBack') === 'true';
			lastContentDetailId = sessionStorage.getItem('currentViewingContentId');
			
			// 사용 후 초기화
			sessionStorage.removeItem('wasNavigatingBack');
			
			if (wasNavigatingBack) {
				console.log('브라우저 뒤로가기 감지: 세션스토리지 플래그 확인됨');
				
				// 마지막으로 본 컨텐츠 ID가 있는지 확인
				if (lastContentDetailId) {
					console.log('마지막으로 본 컨텐츠 ID:', lastContentDetailId);
				}
			}
		} catch (e) {
			console.error('로컬 상태 초기화 오류:', e);
		}
	}

	// 홈 페이지 상태 저장을 위한 객체
	let homeState = $state({
		reviews: [] as ReviewItem[],
		page: 1,
		scrollPosition: 0,
		activeTab: 0,
		type: 'popularity',
		expandedTexts: {} as Record<string, boolean>
	});

	let showNav = $state(true);
	let showSidebar = $state(false);
	let scrollableArea: HTMLDivElement | undefined = $state();
	let y = $state(0);
	let refreshMessage = $state('');
	let isNoMoreData = $state(false);
	// latest,popularity
	let type = $state('popularity');
	
	// 이전 페이지 추적 변수

	// 스크롤 매니저 인스턴스 생성
	const scrollManager = new ScrollManager({
		headerThreshold: 5,
		refreshThreshold: -100,
		debug: false // 개발 중 디버그 모드 활성화
	});
	
	function toggleSidebar(): void {
		console.log('사이드바 토글');
		showSidebar = !showSidebar;
	}
	
	$effect(() => {
		console.log('onMount 실행됨');
		
		// 스크롤 매니저 초기화
		const cleanup = scrollManager.initialize();
		
		// 스크롤 컨테이너 요소 설정
		if (scrollableArea) {
			scrollManager.setContainerElement(scrollableArea);
		}
		
		// 스크롤 이벤트 구독
		const unsubscribeScroll = scrollManager.onScroll((scrollPosition) => {
			y = scrollPosition;
			// 스크롤 위치 homeState에 저장
			homeState.scrollPosition = scrollPosition;
		});
		
		// 위로 스크롤 시 헤더 표시
		const unsubscribeScrollUp = scrollManager.onDirectionChange(
			ScrollDirection.UP,
			() => {
				if (!showNav) {
					showNav = true;
				}
			}
		);
		
		// 아래로 스크롤 시 헤더 숨김
		const unsubscribeScrollDown = scrollManager.onDirectionChange(
			ScrollDirection.DOWN,
			() => {
				if (showNav) {
					showNav = false;
				}
			}
		);
		
		// 새로고침 트리거 이벤트 구독
		const unsubscribeRefresh = scrollManager.onRefreshTriggered((position) => {
			refreshMessage = `새로고침 트리거 (${position}px)`;
			console.log('새로고침 트리거:', position);
			
			// 3초 후 메시지 지우기
			setTimeout(() => {
				refreshMessage = '';
			}, 3000);
		});
		
		// 컴포넌트 정리 함수 반환
		return () => {
			// 컴포넌트가 언마운트될 때 상태 저장
			saveHomeState();
			
			cleanup();
			unsubscribeScroll();
			unsubscribeScrollUp();
			unsubscribeScrollDown();
			unsubscribeRefresh();
		};
	});

	// 상태 관리
	let loading = $state(true);
	let reviews: ReviewItem[] = $state([]);
	let page = $state(1);
	let size = $state(20);
	let expandedTexts = $state<Record<string, boolean>>({});
	let activeTab = $state(0); // 활성 탭 인덱스 추가

	// 탭 정보
	const tabs = [
  { id: 'popularity', label: '인기', desc: '최근 3개월 동안 많은 사람들의 관심을 받은 리뷰를 모아 보여드려요.', emoji: '', view:'mv_place_review_popularity_for_3m_10k' },
  { id: 'hidden_gem', label: '발견', desc: '아직 많이 알려지지 않았지만, 품질 좋은 리뷰로 뽑힌 맛집을 찾아드려요.', emoji: '', view:'mv_place_review_hidden_gem_for_10k' },
//   { id: 'seasonal', label: '시즌', desc: '지금 계절에 딱 어울리는, 최근 2년간 계절별 인기 리뷰를 소개합니다.', emoji: '', view:'mv_place_review_seasonal_for_2y_10k' },
  { id: 'visit_count', label: '단골', desc: '여러 번 방문한 단골들이 남긴 신뢰도 높은 리뷰만 모아서 보여드려요.', emoji: '', view:'mv_place_review_regular_customer_for_10k' },
  { id: 'latest', label: '최신', desc: '가장 최근에 등록된 따끈한 리뷰들을 모았어요. 최신 트렌드를 놓치지 마세요.', emoji: '', view:'mv_place_review_popularity_for_3m_10k' },
  { id: 'my_liked', label: '좋아요', desc: '내가 "좋아요"를 누른 리뷰만 모아서 한 번에 볼 수 있도록 보여드려요.', emoji: '', view:'mv_place_review_my_liked_for_10k' },
]

	// 홈 페이지 상태 저장 함수
	function saveHomeState() {
		homeState = {
			reviews,
			page,
			scrollPosition: y,
			activeTab,
			type,
			expandedTexts
		};
		
		console.log('홈 페이지 상태 저장');
		
		try {
			// 상태 저장 시 타임스탬프와 함께 저장 (나중에 상태의 신선도 확인용)
			const stateWithMeta = {
				data: homeState,
				timestamp: new Date().getTime(),
				source: 'homePageState'
			};
			
			// 세션스토리지만 사용 (모바일 성능 최적화)
			sessionStorage.setItem('homeUIState', JSON.stringify(stateWithMeta));
			
			console.log('홈 상태 저장 완료');
		} catch (error) {
			console.error('상태 저장 실패:', error);
		}
	}
	
	// 홈 페이지 상태 복원 함수
	function restoreHomeState() {
		try {
			// 세션스토리지에서만 시도 (localStorage 접근 제거)
			const savedStateJson = sessionStorage.getItem('homeUIState');
			
			if (!savedStateJson) {
				console.log('저장된 상태 없음: 새로운 데이터 로드 필요');
				return false;
			}
			
			console.log('저장된 상태 발견');
			
			const savedStateMeta = JSON.parse(savedStateJson);
			const parsedState = savedStateMeta.data;
			const timestamp = savedStateMeta.timestamp;
			
			// 타임스탬프 확인 (5분 이상 지난 데이터는 신선하지 않은 것으로 간주 - 시간 단축)
			const now = new Date().getTime();
			const isStale = now - timestamp > 5 * 60 * 1000; // 5분
			
			if (isStale) {
				console.log('저장된 상태가 오래됨 (5분 초과)');
				sessionStorage.removeItem('homeUIState');
				return false;
			}
			
			console.log('저장된 상태 복원 중');
			
			// 필요한 상태들 복원
			reviews = parsedState.reviews || [];
			page = parsedState.page || 1;
			activeTab = parsedState.activeTab ?? 0;
			type = parsedState.type || 'popularity';
			expandedTexts = parsedState.expandedTexts || {};
			
			// 스크롤 위치 복원
			if (scrollableArea && parsedState.scrollPosition) {
				console.log('스크롤 위치 복원 예정:', parsedState.scrollPosition);
				// RAF를 사용하여 DOM 업데이트 후 스크롤 적용 (setTimeout 추가로 안정성 향상)
				setTimeout(() => {
					requestAnimationFrame(() => {
						if (scrollableArea) {
							console.log('스크롤 위치 복원 실행');
							scrollableArea.scrollTop = parsedState.scrollPosition;
						}
					});
				}, 0);
			}
			
			// 복원 후 상태 제거 (중요: 일회성 사용 보장)
			sessionStorage.removeItem('homeUIState');
			console.log('저장된 상태 복원 및 삭제 완료');
			
			return true;
		} catch (error) {
			console.error('상태 복원 실패:', error);
			sessionStorage.removeItem('homeUIState');
		}
		
		return false;
	}

	// 탭 변경 함수
	function handleTabChange(index: number) {
		activeTab = index;
		type = tabs[activeTab].id;
		page = 1;
		reviews = [];
		isNoMoreData = false;
		loadReviews(page, size, type);
		
		// URL 변경
		goto(`/home/tab/${tabs[activeTab].id}`, { replace: true });
		
		// 스크롤을 맨 위로 이동
		scrollManager.scrollToTop('auto');
	}

	// 날짜 포맷팅 함수
	function formatDate(dateString: string): string {
		if (!dateString) return '';

		const year = dateString.substring(0, 4);
		const month = dateString.substring(4, 6);
		const day = dateString.substring(6, 8);

		return `${year}.${month}.${day}`;
	}

	// 텍스트 자르기 함수

	// 텍스트 확장/축소 토글
	function toggleExpandText(reviewId: string): void {
		expandedTexts[reviewId] = !expandedTexts[reviewId];
		expandedTexts = { ...expandedTexts };
	}

	// 리뷰 데이터 로드
	async function loadReviews(currentPage: number = 1, pageSize: number = 20, type: string = 'latest'): Promise<void> {
		try {
			loading = true;
			// Supabase 서비스를 사용하여 리뷰 데이터 가져오기
			const response = await reviewService.getReviewList2({
				page: currentPage,
				size: pageSize,
				type: type,
			});
			
			if (response && response.result && Array.isArray(response.result.rows)) {
				reviews = response.result.rows;
				isNoMoreData = response.result.rows.length !== size;
				console.log(`isNoMoreData: ${isNoMoreData}`);

				// 초기 expandedTexts 세팅
				const initialExpandedState: Record<string, boolean> = {};
				reviews.forEach((review: ReviewItem) => {
					initialExpandedState[review.id] = false;
				});
				expandedTexts = initialExpandedState;
			}
		} catch (error) {
			console.error('리뷰 데이터 로드 실패:', error);
		} finally {
			loading = false;
		}
	}

	// 카테고리에 맞는 배경색 반환

	// 주소를 태그로 변환


	// 장소 상세 페이지로 이동 (팝업 사용 대신 URL 이동 방식으로 변경)
	function goToPlaceDetail(businessId: string): void {
		console.log('장소 상세 페이지로 이동:', businessId);
		
		// 현재 홈 페이지 상태 저장 (상세 페이지로 이동 전)
		saveHomeState();
		
		// 현재 보고 있는 컨텐츠 ID 저장
		try {
			localStorage.setItem('currentViewingContentId', businessId);
			console.log('현재 보는 컨텐츠 ID 저장:', businessId);
		} catch (e) {
			console.error('ID 저장 오류:', e);
		}
		
		// 상태 정보 준비
		const state = { 
			fromHome: true, 
			hasHomeState: true,
			businessId,
			savedAt: new Date().getTime()
		};
		
		// SPA 라우터 사용하여 이동 (state 옵션 사용)
		try {
			goto(`/place/${businessId}`, { state });
			console.log('라우터로 이동 완료, 상태 정보:', state);
		} catch (e) {
			// 오류 발생 시 대체 방법으로 이동
			console.error('라우터 사용 오류:', e);
			location.href = `/place/${businessId}`;
		}
	}

	// 네이버 장소 링크로 이동

	// 추가 리뷰 데이터 로드
	async function loadMoreReviewsData(): Promise<void> {
		try {
			loading = true;
			const response = await reviewService.getReviewList2({
				page: page,
				size: size,
				type: type,
			});

			if (response && response.result && Array.isArray(response.result.rows)) {
				const newReviews = response.result.rows;

				// 새 리뷰에 대한 expandedTexts 세팅
				const newExpandedState: Record<string, boolean> = { ...expandedTexts };
				newReviews.forEach((review: ReviewItem) => {
					newExpandedState[review.id] = false;
				});
				expandedTexts = newExpandedState;

				// 리뷰 데이터 병합
				reviews = [...reviews, ...newReviews];
				isNoMoreData = newReviews.length !== size;
			}
		} catch (error) {
			console.error('추가 리뷰 데이터 로드 실패:', error);
		} finally {
			loading = false;
		}
	}

	// 더 많은 리뷰 로드
	function loadMoreReviews(): void {
		if (loading || isNoMoreData) return;

		page += 1;
		loadMoreReviewsData();
	}

	// 스크롤 이벤트 핸들러
	let isScrollListenerAdded = false;

	function handleScroll(): void {
		if (loading || isNoMoreData) return;

		if (!scrollableArea) return;

		const { scrollTop, scrollHeight, clientHeight } = scrollableArea;

		// 스크롤이 하단에 가까워지면 추가 데이터 로드
		if (scrollTop + clientHeight >= scrollHeight - 300) {
			loadMoreReviews();
		}
	}

	$effect(() => {
		if (scrollableArea && !isScrollListenerAdded) {
			scrollableArea.addEventListener('scroll', handleScroll);
			isScrollListenerAdded = true;
		}
	});

	// 네비게이션 타입 감지 함수
	function detectNavigationType(): { isBackNavigation: boolean; source: string; isDirectNavigation: boolean } {
		// 브라우저 뒤로가기 감지를 위한 여러 기법 적용
		try {
			// 1. Performance API 활용 (가장 신뢰할 수 있는 방법)
			const navigationEntries = window.performance?.getEntriesByType?.('navigation') || [];
			const navigationEntry = navigationEntries[0] as PerformanceNavigationTiming;
			const navigationType = navigationEntry?.type || 'unknown';
			const isBackForward = navigationType === 'back_forward';
			
			// 2. localStorage 플래그 확인 (다른 페이지에서 설정됨)
			const localBackFlag = wasNavigatingBack;
			
			// 3. 현재 history.state 확인
			const currentState = history.state || {};
			const historyBackFlag = currentState.isBackNavigation === true || 
			                        (currentState.fromContentDetail === true) ||
			                        (currentState.fromPlaceDetail === true);
			
			// history.state에서 추가 정보 확인
			const fromDetailPage = currentState.fromContentDetail || currentState.fromPlaceDetail;
			const stateBusinessId = currentState.businessId;
			
			// 4. sessionStorage 플래그 확인
			const sessionBackFlag = sessionStorage.getItem('isBackNavigation') === 'true';
			sessionStorage.removeItem('isBackNavigation');
			
			// 5. Referrer 확인 (이전 페이지 URL 체크)
			const referrer = document.referrer || '';
			const isFromContentDetail = referrer.includes('/place/') || referrer.includes('/content/');
			
			// 6. 새로고침 감지
			const isReload = navigationType === 'reload';
			
			// 7. 직접 접근(URL 입력, 메뉴를 통한 접근) 감지
			const isDirectNavigation = navigationType === 'navigate' && !isFromContentDetail;
			
			// 로깅
			console.log('네비게이션 타입 감지 결과:', {
				isBackForward,
				localBackFlag,
				historyBackFlag,
				sessionBackFlag,
				isFromContentDetail,
				referrer,
				navigationType,
				isReload,
				isDirectNavigation,
				historyState: currentState,
				stateBusinessId
			});
			
			// 각 감지 방법의 결과 종합
			const isBackNavigation = isBackForward || localBackFlag || historyBackFlag || 
									sessionBackFlag || isFromContentDetail;
			
			// 뒤로가기의 출처 식별
			let source = 'unknown';
			if (isBackForward) source = 'performance_api';
			else if (localBackFlag) source = 'localStorage';
			else if (historyBackFlag) source = 'history_state';
			else if (sessionBackFlag) source = 'sessionStorage';
			else if (isFromContentDetail) source = 'referrer';
			else if (isReload) source = 'reload';
			else if (isDirectNavigation) source = 'direct';
			
			// 뒤로가기로 확인되었고 state에 상세 정보가 있는 경우
			if (isBackNavigation && fromDetailPage && stateBusinessId) {
				console.log('상세 페이지에서 뒤로가기로 돌아옴, 컨텐츠 ID:', stateBusinessId);
				// 필요시 여기에 추가 처리 코드 작성
			}
			
			return { isBackNavigation, source, isDirectNavigation };
		} catch (err) {
			console.error('네비게이션 타입 감지 오류:', err);
			return { isBackNavigation: false, source: 'error', isDirectNavigation: true };
		}
	}

	// 컴포넌트 마운트 시 실행
	onMount(() => {
		console.log('onMount: 홈 페이지 로드 시작');
		
		// URL 파라미터에서 탭 ID 읽기
		const urlParams = new URLSearchParams(window.location.search);
		const pathArray = window.location.pathname.split('/');
		const tabIdFromUrl = pathArray.length > 3 && pathArray[2] === 'tab' ? pathArray[3] : null;
		
		// URL의 탭 ID가 있으면 해당 탭으로 설정
		if (tabIdFromUrl) {
			console.log('URL 파라미터에서 탭 ID 감지:', tabIdFromUrl);
			const tabIndex = tabs.findIndex(tab => tab.id === tabIdFromUrl);
			if (tabIndex !== -1) {
				activeTab = tabIndex;
				type = tabs[activeTab].id;
				console.log('탭 인덱스를 URL 파라미터로 설정:', activeTab);
			}
		}
		
		// 네비게이션 타입 감지
		const { isBackNavigation, source, isDirectNavigation } = detectNavigationType();
		console.log(`네비게이션 타입: ${isBackNavigation ? '뒤로가기' : '일반 접근'} (출처: ${source})`);
		
		// 스크롤 매니저 초기화
		const cleanup = scrollManager.initialize();
		
		// 스크롤 컨테이너 요소 설정
		if (scrollableArea) {
			scrollManager.setContainerElement(scrollableArea);
		}
		
		// 스크롤 이벤트 구독
		const unsubscribeScroll = scrollManager.onScroll((scrollPosition) => {
			y = scrollPosition;
			// 스크롤 위치 homeState에 저장
			homeState.scrollPosition = scrollPosition;
		});
		
		// 위로 스크롤 시 헤더 표시
		const unsubscribeScrollUp = scrollManager.onDirectionChange(
			ScrollDirection.UP,
			() => {
				if (!showNav) {
					showNav = true;
				}
			}
		);
		
		// 아래로 스크롤 시 헤더 숨김
		const unsubscribeScrollDown = scrollManager.onDirectionChange(
			ScrollDirection.DOWN,
			() => {
				if (showNav) {
					showNav = false;
				}
			}
		);
		
		// 새로고침 트리거 이벤트 구독
		const unsubscribeRefresh = scrollManager.onRefreshTriggered((position) => {
			refreshMessage = `새로고침 트리거 (${position}px)`;
			console.log('새로고침 트리거:', position);
			
			// 3초 후 메시지 지우기
			setTimeout(() => {
				refreshMessage = '';
			}, 3000);
		});
		
		// 컴포넌트 정리 함수 반환
		return () => {
			// 컴포넌트가 언마운트될 때 상태 저장
			saveHomeState();
			
			cleanup();
			unsubscribeScroll();
			unsubscribeScrollUp();
			unsubscribeScrollDown();
			unsubscribeRefresh();
		};
	});
});
</script>

<script lang="ts">
	import { onMount } from 'svelte';
	import { goto } from '@mateothegreat/svelte5-router';
	import { formatWithCommas } from '$utils/number.util';
	import { ScrollManager, ScrollDirection } from '$lib/utils/ScrollManager';
	import ProfileSidebar from './ProfileSidebar.svelte';
	import Header from './Header.svelte';
	import PlaceDetailPopup from '$lib/components/popup/PlaceDetailPopup.svelte';
	import { detailPopupService } from '$lib/components/popup/DetailPopupService.svelte';
	import Detail from '../place/Detail.svelte';
	import ReviewCard from './components/ReviewCard.svelte';
	import { supabaseReviewService } from '$services/supabase';
	import { reviewService, type ReviewItem } from '$services/review.service';
	import Indicator from '$lib/components/Indicator.svelte';
	import Tabs from '$lib/components/ui/Tabs.svelte';

	// 타입 오류 해결을 위한 타입 선언
	interface ReviewItem {
		id: string;
		business_id: string;
		[key: string]: any;
	}

	// URL 파라미터에서 tabId를 받아오는 부분 추가
	let tabId = $state('');
	
	// props로부터 tabId를 받아옵니다
	let props = $props();
	
	$effect(() => {
		// URL 파라미터에서 tabId 추출
		const pathArray = window.location.pathname.split('/');
		if (pathArray.length > 3 && pathArray[2] === 'tab') {
			tabId = pathArray[3];
		}
	});

	// 브라우저 환경에서만 초기화되는 로컬 상태 변수들
	let wasNavigatingBack = false;
	let lastContentDetailId: string | null = null;
	
	// 브라우저 환경에서만 실행되는 초기화 (SSR 고려)
	if (typeof window !== 'undefined') {
		// 세션스토리지에서 상태 체크 (localStorage 접근 최소화)
		try {
			wasNavigatingBack = sessionStorage.getItem('wasNavigatingBack') === 'true';
			lastContentDetailId = sessionStorage.getItem('currentViewingContentId');
			
			// 사용 후 초기화
			sessionStorage.removeItem('wasNavigatingBack');
			
			if (wasNavigatingBack) {
				console.log('브라우저 뒤로가기 감지: 세션스토리지 플래그 확인됨');
				
				// 마지막으로 본 컨텐츠 ID가 있는지 확인
				if (lastContentDetailId) {
					console.log('마지막으로 본 컨텐츠 ID:', lastContentDetailId);
				}
			}
		} catch (e) {
			console.error('로컬 상태 초기화 오류:', e);
		}
	}

	// 홈 페이지 상태 저장을 위한 객체
	let homeState = $state({
		reviews: [] as ReviewItem[],
		page: 1,
		scrollPosition: 0,
		activeTab: 0,
		type: 'popularity',
		expandedTexts: {} as Record<string, boolean>
	});

	let showNav = $state(true);
	let showSidebar = $state(false);
	let scrollableArea: HTMLDivElement | undefined = $state();
	let y = $state(0);
	let refreshMessage = $state('');
	let isNoMoreData = $state(false);
	// latest,popularity
	let type = $state('popularity');
	
	// 이전 페이지 추적 변수

	// 스크롤 매니저 인스턴스 생성
	const scrollManager = new ScrollManager({
		headerThreshold: 5,
		refreshThreshold: -100,
		debug: false // 개발 중 디버그 모드 활성화
	});
	
	function toggleSidebar(): void {
		console.log('사이드바 토글');
		showSidebar = !showSidebar;
	}
	
	$effect(() => {
		console.log('onMount 실행됨');
		
		// 스크롤 매니저 초기화
		const cleanup = scrollManager.initialize();
		
		// 스크롤 컨테이너 요소 설정
		if (scrollableArea) {
			scrollManager.setContainerElement(scrollableArea);
		}
		
		// 스크롤 이벤트 구독
		const unsubscribeScroll = scrollManager.onScroll((scrollPosition) => {
			y = scrollPosition;
			// 스크롤 위치 homeState에 저장
			homeState.scrollPosition = scrollPosition;
		});
		
		// 위로 스크롤 시 헤더 표시
		const unsubscribeScrollUp = scrollManager.onDirectionChange(
			ScrollDirection.UP,
			() => {
				if (!showNav) {
					showNav = true;
				}
			}
		);
		
		// 아래로 스크롤 시 헤더 숨김
		const unsubscribeScrollDown = scrollManager.onDirectionChange(
			ScrollDirection.DOWN,
			() => {
				if (showNav) {
					showNav = false;
				}
			}
		);
		
		// 새로고침 트리거 이벤트 구독
		const unsubscribeRefresh = scrollManager.onRefreshTriggered((position) => {
			refreshMessage = `새로고침 트리거 (${position}px)`;
			console.log('새로고침 트리거:', position);
			
			// 3초 후 메시지 지우기
			setTimeout(() => {
				refreshMessage = '';
			}, 3000);
		});
		
		// 컴포넌트 정리 함수 반환
		return () => {
			// 컴포넌트가 언마운트될 때 상태 저장
			saveHomeState();
			
			cleanup();
			unsubscribeScroll();
			unsubscribeScrollUp();
			unsubscribeScrollDown();
			unsubscribeRefresh();
		};
	});

	// 상태 관리
	let loading = $state(true);
	let reviews: ReviewItem[] = $state([]);
	let page = $state(1);
	let size = $state(20);
	let expandedTexts = $state<Record<string, boolean>>({});
	let activeTab = $state(0); // 활성 탭 인덱스 추가

	// 탭 정보
	const tabs = [
  { id: 'popularity', label: '인기', desc: '최근 3개월 동안 많은 사람들의 관심을 받은 리뷰를 모아 보여드려요.', emoji: '', view:'mv_place_review_popularity_for_3m_10k' },
  { id: 'hidden_gem', label: '발견', desc: '아직 많이 알려지지 않았지만, 품질 좋은 리뷰로 뽑힌 맛집을 찾아드려요.', emoji: '', view:'mv_place_review_hidden_gem_for_10k' },
//   { id: 'seasonal', label: '시즌', desc: '지금 계절에 딱 어울리는, 최근 2년간 계절별 인기 리뷰를 소개합니다.', emoji: '', view:'mv_place_review_seasonal_for_2y_10k' },
  { id: 'visit_count', label: '단골', desc: '여러 번 방문한 단골들이 남긴 신뢰도 높은 리뷰만 모아서 보여드려요.', emoji: '', view:'mv_place_review_regular_customer_for_10k' },
  { id: 'latest', label: '최신', desc: '가장 최근에 등록된 따끈한 리뷰들을 모았어요. 최신 트렌드를 놓치지 마세요.', emoji: '', view:'mv_place_review_popularity_for_3m_10k' },
  { id: 'my_liked', label: '좋아요', desc: '내가 "좋아요"를 누른 리뷰만 모아서 한 번에 볼 수 있도록 보여드려요.', emoji: '', view:'mv_place_review_my_liked_for_10k' },
]

	// 홈 페이지 상태 저장 함수
	function saveHomeState() {
		homeState = {
			reviews,
			page,
			scrollPosition: y,
			activeTab,
			type,
			expandedTexts
		};
		
		console.log('홈 페이지 상태 저장');
		
		try {
			// 상태 저장 시 타임스탬프와 함께 저장 (나중에 상태의 신선도 확인용)
			const stateWithMeta = {
				data: homeState,
				timestamp: new Date().getTime(),
				source: 'homePageState'
			};
			
			// 세션스토리지만 사용 (모바일 성능 최적화)
			sessionStorage.setItem('homeUIState', JSON.stringify(stateWithMeta));
			
			console.log('홈 상태 저장 완료');
		} catch (error) {
			console.error('상태 저장 실패:', error);
		}
	}
	
	// 홈 페이지 상태 복원 함수
	function restoreHomeState() {
		try {
			// 세션스토리지에서만 시도 (localStorage 접근 제거)
			const savedStateJson = sessionStorage.getItem('homeUIState');
			
			if (!savedStateJson) {
				console.log('저장된 상태 없음: 새로운 데이터 로드 필요');
				return false;
			}
			
			console.log('저장된 상태 발견');
			
			const savedStateMeta = JSON.parse(savedStateJson);
			const parsedState = savedStateMeta.data;
			const timestamp = savedStateMeta.timestamp;
			
			// 타임스탬프 확인 (5분 이상 지난 데이터는 신선하지 않은 것으로 간주 - 시간 단축)
			const now = new Date().getTime();
			const isStale = now - timestamp > 5 * 60 * 1000; // 5분
			
			if (isStale) {
				console.log('저장된 상태가 오래됨 (5분 초과)');
				sessionStorage.removeItem('homeUIState');
				return false;
			}
			
			console.log('저장된 상태 복원 중');
			
			// 필요한 상태들 복원
			reviews = parsedState.reviews || [];
			page = parsedState.page || 1;
			activeTab = parsedState.activeTab ?? 0;
			type = parsedState.type || 'popularity';
			expandedTexts = parsedState.expandedTexts || {};
			
			// 스크롤 위치 복원
			if (scrollableArea && parsedState.scrollPosition) {
				console.log('스크롤 위치 복원 예정:', parsedState.scrollPosition);
				// RAF를 사용하여 DOM 업데이트 후 스크롤 적용 (setTimeout 추가로 안정성 향상)
				setTimeout(() => {
					requestAnimationFrame(() => {
						if (scrollableArea) {
							console.log('스크롤 위치 복원 실행');
							scrollableArea.scrollTop = parsedState.scrollPosition;
						}
					});
				}, 0);
			}
			
			// 복원 후 상태 제거 (중요: 일회성 사용 보장)
			sessionStorage.removeItem('homeUIState');
			console.log('저장된 상태 복원 및 삭제 완료');
			
			return true;
		} catch (error) {
			console.error('상태 복원 실패:', error);
			sessionStorage.removeItem('homeUIState');
		}
		
		return false;
	}

	// 탭 변경 함수
	function handleTabChange(index: number) {
		activeTab = index;
		type = tabs[activeTab].id;
		page = 1;
		reviews = [];
		isNoMoreData = false;
		loadReviews(page, size, type);
		
		// URL 변경
		goto(`/home/tab/${tabs[activeTab].id}`, { replace: true });
		
		// 스크롤을 맨 위로 이동
		scrollManager.scrollToTop('auto');
	}

	// 날짜 포맷팅 함수
	function formatDate(dateString: string): string {
		if (!dateString) return '';

		const year = dateString.substring(0, 4);
		const month = dateString.substring(4, 6);
		const day = dateString.substring(6, 8);

		return `${year}.${month}.${day}`;
	}

	// 텍스트 자르기 함수

	// 텍스트 확장/축소 토글
	function toggleExpandText(reviewId: string): void {
		expandedTexts[reviewId] = !expandedTexts[reviewId];
		expandedTexts = { ...expandedTexts };
	}

	// 리뷰 데이터 로드
	async function loadReviews(currentPage: number = 1, pageSize: number = 20, type: string = 'latest'): Promise<void> {
		try {
			loading = true;
			// Supabase 서비스를 사용하여 리뷰 데이터 가져오기
			const response = await reviewService.getReviewList2({
				page: currentPage,
				size: pageSize,
				type: type,
			});
			
			if (response && response.result && Array.isArray(response.result.rows)) {
				reviews = response.result.rows;
				isNoMoreData = response.result.rows.length !== size;
				console.log(`isNoMoreData: ${isNoMoreData}`);

				// 초기 expandedTexts 세팅
				const initialExpandedState: Record<string, boolean> = {};
				reviews.forEach((review: ReviewItem) => {
					initialExpandedState[review.id] = false;
				});
				expandedTexts = initialExpandedState;
			}
		} catch (error) {
			console.error('리뷰 데이터 로드 실패:', error);
		} finally {
			loading = false;
		}
	}

	// 카테고리에 맞는 배경색 반환

	// 주소를 태그로 변환


	// 장소 상세 페이지로 이동 (팝업 사용 대신 URL 이동 방식으로 변경)
	function goToPlaceDetail(businessId: string): void {
		console.log('장소 상세 페이지로 이동:', businessId);
		
		// 현재 홈 페이지 상태 저장 (상세 페이지로 이동 전)
		saveHomeState();
		
		// 현재 보고 있는 컨텐츠 ID 저장
		try {
			localStorage.setItem('currentViewingContentId', businessId);
			console.log('현재 보는 컨텐츠 ID 저장:', businessId);
		} catch (e) {
			console.error('ID 저장 오류:', e);
		}
		
		// 상태 정보 준비
		const state = { 
			fromHome: true, 
			hasHomeState: true,
			businessId,
			savedAt: new Date().getTime()
		};
		
		// SPA 라우터 사용하여 이동 (state 옵션 사용)
		try {
			goto(`/place/${businessId}`, { state });
			console.log('라우터로 이동 완료, 상태 정보:', state);
		} catch (e) {
			// 오류 발생 시 대체 방법으로 이동
			console.error('라우터 사용 오류:', e);
			location.href = `/place/${businessId}`;
		}
	}

	// 네이버 장소 링크로 이동

	// 추가 리뷰 데이터 로드
	async function loadMoreReviewsData(): Promise<void> {
		try {
			loading = true;
			const response = await reviewService.getReviewList2({
				page: page,
				size: size,
				type: type,
			});

			if (response && response.result && Array.isArray(response.result.rows)) {
				const newReviews = response.result.rows;

				// 새 리뷰에 대한 expandedTexts 세팅
				const newExpandedState: Record<string, boolean> = { ...expandedTexts };
				newReviews.forEach((review: ReviewItem) => {
					newExpandedState[review.id] = false;
				});
				expandedTexts = newExpandedState;

				// 리뷰 데이터 병합
				reviews = [...reviews, ...newReviews];
				isNoMoreData = newReviews.length !== size;
			}
		} catch (error) {
			console.error('추가 리뷰 데이터 로드 실패:', error);
		} finally {
			loading = false;
		}
	}

	// 더 많은 리뷰 로드
	function loadMoreReviews(): void {
		if (loading || isNoMoreData) return;

		page += 1;
		loadMoreReviewsData();
	}

	// 스크롤 이벤트 핸들러
	let isScrollListenerAdded = false;

	function handleScroll(): void {
		if (loading || isNoMoreData) return;

		if (!scrollableArea) return;

		const { scrollTop, scrollHeight, clientHeight } = scrollableArea;

		// 스크롤이 하단에 가까워지면 추가 데이터 로드
		if (scrollTop + clientHeight >= scrollHeight - 300) {
			loadMoreReviews();
		}
	}

	$effect(() => {
		if (scrollableArea && !isScrollListenerAdded) {
			scrollableArea.addEventListener('scroll', handleScroll);
			isScrollListenerAdded = true;
		}
	});

	// 네비게이션 타입 감지 함수
	function detectNavigationType(): { isBackNavigation: boolean; source: string; isDirectNavigation: boolean } {
		// 브라우저 뒤로가기 감지를 위한 여러 기법 적용
		try {
			// 1. Performance API 활용 (가장 신뢰할 수 있는 방법)
			const navigationEntries = window.performance?.getEntriesByType?.('navigation') || [];
			const navigationEntry = navigationEntries[0] as PerformanceNavigationTiming;
			const navigationType = navigationEntry?.type || 'unknown';
			const isBackForward = navigationType === 'back_forward';
			
			// 2. localStorage 플래그 확인 (다른 페이지에서 설정됨)
			const localBackFlag = wasNavigatingBack;
			
			// 3. 현재 history.state 확인
			const currentState = history.state || {};
			const historyBackFlag = currentState.isBackNavigation === true || 
			                        (currentState.fromContentDetail === true) ||
			                        (currentState.fromPlaceDetail === true);
			
			// history.state에서 추가 정보 확인
			const fromDetailPage = currentState.fromContentDetail || currentState.fromPlaceDetail;
			const stateBusinessId = currentState.businessId;
			
			// 4. sessionStorage 플래그 확인
			const sessionBackFlag = sessionStorage.getItem('isBackNavigation') === 'true';
			sessionStorage.removeItem('isBackNavigation');
			
			// 5. Referrer 확인 (이전 페이지 URL 체크)
			const referrer = document.referrer || '';
			const isFromContentDetail = referrer.includes('/place/') || referrer.includes('/content/');
			
			// 6. 새로고침 감지
			const isReload = navigationType === 'reload';
			
			// 7. 직접 접근(URL 입력, 메뉴를 통한 접근) 감지
			const isDirectNavigation = navigationType === 'navigate' && !isFromContentDetail;
			
			// 로깅
			console.log('네비게이션 타입 감지 결과:', {
				isBackForward,
				localBackFlag,
				historyBackFlag,
				sessionBackFlag,
				isFromContentDetail,
				referrer,
				navigationType,
				isReload,
				isDirectNavigation,
				historyState: currentState,
				stateBusinessId
			});
			
			// 각 감지 방법의 결과 종합
			const isBackNavigation = isBackForward || localBackFlag || historyBackFlag || 
									sessionBackFlag || isFromContentDetail;
			
			// 뒤로가기의 출처 식별
			let source = 'unknown';
			if (isBackForward) source = 'performance_api';
			else if (localBackFlag) source = 'localStorage';
			else if (historyBackFlag) source = 'history_state';
			else if (sessionBackFlag) source = 'sessionStorage';
			else if (isFromContentDetail) source = 'referrer';
			else if (isReload) source = 'reload';
			else if (isDirectNavigation) source = 'direct';
			
			// 뒤로가기로 확인되었고 state에 상세 정보가 있는 경우
			if (isBackNavigation && fromDetailPage && stateBusinessId) {
				console.log('상세 페이지에서 뒤로가기로 돌아옴, 컨텐츠 ID:', stateBusinessId);
				// 필요시 여기에 추가 처리 코드 작성
			}
			
			return { isBackNavigation, source, isDirectNavigation };
		} catch (err) {
			console.error('네비게이션 타입 감지 오류:', err);
			return { isBackNavigation: false, source: 'error', isDirectNavigation: true };
		}
	}

	// 컴포넌트 마운트 시 실행
	onMount(() => {
		console.log('onMount: 홈 페이지 로드 시작');
		
		// URL 파라미터에서 탭 ID 읽기
		const urlParams = new URLSearchParams(window.location.search);
		const pathArray = window.location.pathname.split('/');
		const tabIdFromUrl = pathArray.length > 3 && pathArray[2] === 'tab' ? pathArray[3] : null;
		
		// URL의 탭 ID가 있으면 해당 탭으로 설정
		if (tabIdFromUrl) {
			console.log('URL 파라미터에서 탭 ID 감지:', tabIdFromUrl);
			const tabIndex = tabs.findIndex(tab => tab.id === tabIdFromUrl);
			if (tabIndex !== -1) {
				activeTab = tabIndex;
				type = tabs[activeTab].id;
				console.log('탭 인덱스를 URL 파라미터로 설정:', activeTab);
			}
		}
		
		// 네비게이션 타입 감지
		const { isBackNavigation, source, isDirectNavigation } = detectNavigationType();
		console.log(`네비게이션 타입: ${isBackNavigation ? '뒤로가기' : '일반 접근'} (출처: ${source})`);
		
		// 스크롤 매니저 초기화
		const cleanup = scrollManager.initialize();
		
		// 스크롤 컨테이너 요소 설정
		if (scrollableArea) {
			scrollManager.setContainerElement(scrollableArea);
		}
		
		// 스크롤 이벤트 구독
		const unsubscribeScroll = scrollManager.onScroll((scrollPosition) => {
			y = scrollPosition;
			// 스크롤 위치 homeState에 저장
			homeState.scrollPosition = scrollPosition;
		});
		
		// 위로 스크롤 시 헤더 표시
		const unsubscribeScrollUp = scrollManager.onDirectionChange(
			ScrollDirection.UP,
			() => {
				if (!showNav) {
					showNav = true;
				}
			}
		);
		
		// 아래로 스크롤 시 헤더 숨김
		const unsubscribeScrollDown = scrollManager.onDirectionChange(
			ScrollDirection.DOWN,
			() => {
				if (showNav) {
					showNav = false;
				}
			}
		);
		
		// 새로고침 트리거 이벤트 구독
		const unsubscribeRefresh = scrollManager.onRefreshTriggered((position) => {
			refreshMessage = `새로고침 트리거 (${position}px)`;
			console.log('새로고침 트리거:', position);
			
			// 3초 후 메시지 지우기
			setTimeout(() => {
				refreshMessage = '';
			}, 3000);
		});
		
		// 컴포넌트 정리 함수 반환
		return () => {
			// 컴포넌트가 언마운트될 때 상태 저장
			saveHomeState();
			
			cleanup();
			unsubscribeScroll();
			unsubscribeScrollUp();
			unsubscribeScrollDown();
			unsubscribeRefresh();
		};
	});
});
</script>

<script lang="ts">
	import { onMount } from 'svelte';
	import { goto } from '@mateothegreat/svelte5-router';
	import { formatWithCommas } from '$utils/number.util';
	import { ScrollManager, ScrollDirection } from '$lib/utils/ScrollManager';
	import ProfileSidebar from './ProfileSidebar.svelte';
	import Header from './Header.svelte';
	import PlaceDetailPopup from '$lib/components/popup/PlaceDetailPopup.svelte';
	import { detailPopupService } from '$lib/components/popup/DetailPopupService.svelte';
	import Detail from '../place/Detail.svelte';
	import ReviewCard from './components/ReviewCard.svelte';
	import { supabaseReviewService } from '$services/supabase';
	import { reviewService, type ReviewItem } from '$services/review.service';
	import Indicator from '$lib/components/Indicator.svelte';
	import Tabs from '$lib/components/ui/Tabs.svelte';

	// 타입 오류 해결을 위한 타입 선언
	interface ReviewItem {
		id: string;
		business_id: string;
		[key: string]: any;
	}

	// URL 파라미터에서 tabId를 받아오는 부분 추가
	let tabId = $state('');
	
	// props로부터 tabId를 받아옵니다
	let props = $props();
	
	$effect(() => {
		// URL 파라미터에서 tabId 추출
		const pathArray = window.location.pathname.split('/');
		if (pathArray.length > 3 && pathArray[2] === 'tab') {
			tabId = pathArray[3];
		}
	});

	// 브라우저 환경에서만 초기화되는 로컬 상태 변수들
	let wasNavigatingBack = false;
	let lastContentDetailId: string | null = null;
	
	// 브라우저 환경에서만 실행되는 초기화 (SSR 고려)
	if (typeof window !== 'undefined') {
		// 세션스토리지에서 상태 체크 (localStorage 접근 최소화)
		try {
			wasNavigatingBack = sessionStorage.getItem('wasNavigatingBack') === 'true';
			lastContentDetailId = sessionStorage.getItem('currentViewingContentId');
			
			// 사용 후 초기화
			sessionStorage.removeItem('wasNavigatingBack');
			
			if (wasNavigatingBack) {
				console.log('브라우저 뒤로가기 감지: 세션스토리지 플래그 확인됨');
				
				// 마지막으로 본 컨텐츠 ID가 있는지 확인
				if (lastContentDetailId) {
					console.log('마지막으로 본 컨텐츠 ID:', lastContentDetailId);
				}
			}
		} catch (e) {
			console.error('로컬 상태 초기화 오류:', e);
		}
	}

	// 홈 페이지 상태 저장을 위한 객체
	let homeState = $state({
		reviews: [] as ReviewItem[],
		page: 1,
		scrollPosition: 0,
		activeTab: 0,
		type: 'popularity',
		expandedTexts: {} as Record<string, boolean>
	});

	let showNav = $state(true);
	let showSidebar = $state(false);
	let scrollableArea: HTMLDivElement | undefined = $state();
	let y = $state(0);
	let refreshMessage = $state('');
	let isNoMoreData = $state(false);
	// latest,popularity
	let type = $state('popularity');
	
	// 이전 페이지 추적 변수

	// 스크롤 매니저 인스턴스 생성
	const scrollManager = new ScrollManager({
		headerThreshold: 5,
		refreshThreshold: -100,
		debug: false // 개발 중 디버그 모드 활성화
	});
	
	function toggleSidebar(): void {
		console.log('사이드바 토글');
		showSidebar = !showSidebar;
	}
	
	$effect(() => {
		console.log('onMount 실행됨');
		
		// 스크롤 매니저 초기화
		const cleanup = scrollManager.initialize();
		
		// 스크롤 컨테이너 요소 설정
		if (scrollableArea) {
			scrollManager.setContainerElement(scrollableArea);
		}
		
		// 스크롤 이벤트 구독
		const unsubscribeScroll = scrollManager.onScroll((scrollPosition) => {
			y = scrollPosition;
			// 스크롤 위치 homeState에 저장
			homeState.scrollPosition = scrollPosition;
		});
		
		// 위로 스크롤 시 헤더 표시
		const unsubscribeScrollUp = scrollManager.onDirectionChange(
			ScrollDirection.UP,
			() => {
				if (!showNav) {
					showNav = true;
				}
			}
		);
		
		// 아래로 스크롤 시 헤더 숨김
		const unsubscribeScrollDown = scrollManager.onDirectionChange(
			ScrollDirection.DOWN,
			() => {
				if (showNav) {
					showNav = false;
				}
			}
		);
		
		// 새로고침 트리거 이벤트 구독
		const unsubscribeRefresh = scrollManager.onRefreshTriggered((position) => {
			refreshMessage = `새로고침 트리거 (${position}px)`;
			console.log('새로고침 트리거:', position);
			
			// 3초 후 메시지 지우기
			setTimeout(() => {
				refreshMessage = '';
			}, 3000);
		});
		
		// 컴포넌트 정리 함수 반환
		return () => {
			// 컴포넌트가 언마운트될 때 상태 저장
			saveHomeState();
			
			cleanup();
			unsubscribeScroll();
			unsubscribeScrollUp();
			unsubscribeScrollDown();
			unsubscribeRefresh();
		};
	});

	// 상태 관리
	let loading = $state(true);
	let reviews: ReviewItem[] = $state([]);
	let page = $state(1);
	let size = $state(20);
	let expandedTexts = $state<Record<string, boolean>>({});
	let activeTab = $state(0); // 활성 탭 인덱스 추가

	// 탭 정보
	const tabs = [
  { id: 'popularity', label: '인기', desc: '최근 3개월 동안 많은 사람들의 관심을 받은 리뷰를 모아 보여드려요.', emoji: '', view:'mv_place_review_popularity_for_3m_10k' },
  { id: 'hidden_gem', label: '발견', desc: '아직 많이 알려지지 않았지만, 품질 좋은 리뷰로 뽑힌 맛집을 찾아드려요.', emoji: '', view:'mv_place_review_hidden_gem_for_10k' },
//   { id: 'seasonal', label: '시즌', desc: '지금 계절에 딱 어울리는, 최근 2년간 계절별 인기 리뷰를 소개합니다.', emoji: '', view:'mv_place_review_seasonal_for_2y_10k' },
  { id: 'visit_count', label: '단골', desc: '여러 번 방문한 단골들이 남긴 신뢰도 높은 리뷰만 모아서 보여드려요.', emoji: '', view:'mv_place_review_regular_customer_for_10k' },
  { id: 'latest', label: '최신', desc: '가장 최근에 등록된 따끈한 리뷰들을 모았어요. 최신 트렌드를 놓치지 마세요.', emoji: '', view:'mv_place_review_popularity_for_3m_10k' },
  { id: 'my_liked', label: '좋아요', desc: '내가 "좋아요"를 누른 리뷰만 모아서 한 번에 볼 수 있도록 보여드려요.', emoji: '', view:'mv_place_review_my_liked_for_10k' },
]

	// 홈 페이지 상태 저장 함수
	function saveHomeState() {
		homeState = {
			reviews,
			page,
			scrollPosition: y,
			activeTab,
			type,
			expandedTexts
		};
		
		console.log('홈 페이지 상태 저장');
		
		try {
			// 상태 저장 시 타임스탬프와 함께 저장 (나중에 상태의 신선도 확인용)
			const stateWithMeta = {
				data: homeState,
				timestamp: new Date().getTime(),
				source: 'homePageState'
			};
			
			// 세션스토리지만 사용 (모바일 성능 최적화)
			sessionStorage.setItem('homeUIState', JSON.stringify(stateWithMeta));
			
			console.log('홈 상태 저장 완료');
		} catch (error) {
			console.error('상태 저장 실패:', error);
		}
	}
	
	// 홈 페이지 상태 복원 함수
	function restoreHomeState() {
		try {
			// 세션스토리지에서만 시도 (localStorage 접근 제거)
			const savedStateJson = sessionStorage.getItem('homeUIState');
			
			if (!savedStateJson) {
				console.log('저장된 상태 없음: 새로운 데이터 로드 필요');
				return false;
			}
			
			console.log('저장된 상태 발견');
			
			const savedStateMeta = JSON.parse(savedStateJson);
			const parsedState = savedStateMeta.data;
			const timestamp = savedStateMeta.timestamp;
			
			// 타임스탬프 확인 (5분 이상 지난 데이터는 신선하지 않은 것으로 간주 - 시간 단축)
			const now = new Date().getTime();
			const isStale = now - timestamp > 5 * 60 * 1000; // 5분
			
			if (isStale) {
				console.log('저장된 상태가 오래됨 (5분 초과)');
				sessionStorage.removeItem('homeUIState');
				return false;
			}
			
			console.log('저장된 상태 복원 중');
			
			// 필요한 상태들 복원
			reviews = parsedState.reviews || [];
			page = parsedState.page || 1;
			activeTab = parsedState.activeTab ?? 0;
			type = parsedState.type || 'popularity';
			expandedTexts = parsedState.expandedTexts || {};
			
			// 스크롤 위치 복원
			if (scrollableArea && parsedState.scrollPosition) {
				console.log('스크롤 위치 복원 예정:', parsedState.scrollPosition);
				// RAF를 사용하여 DOM 업데이트 후 스크롤 적용 (setTimeout 추가로 안정성 향상)
				setTimeout(() => {
					requestAnimationFrame(() => {
						if (scrollableArea) {
							console.log('스크롤 위치 복원 실행');
							scrollableArea.scrollTop = parsedState.scrollPosition;
						}
					});
				}, 0);
			}
			
			// 복원 후 상태 제거 (중요: 일회성 사용 보장)
			sessionStorage.removeItem('homeUIState');
			console.log('저장된 상태 복원 및 삭제 완료');
			
			return true;
		} catch (error) {
			console.error('상태 복원 실패:', error);
			sessionStorage.removeItem('homeUIState');
		}
		
		return false;
	}

	// 탭 변경 함수
	function handleTabChange(index: number) {
		activeTab = index;
		type = tabs[activeTab].id;
		page = 1;
		reviews = [];
		isNoMoreData = false;
		loadReviews(page, size, type);
		
		// URL 변경
		goto(`/home/tab/${tabs[activeTab].id}`, { replace: true });
		
		// 스크롤을 맨 위로 이동
		scrollManager.scrollToTop('auto');
	}

	// 날짜 포맷팅 함수
	function formatDate(dateString: string): string {
		if (!dateString) return '';

		const year = dateString.substring(0, 4);
		const month = dateString.substring(4, 6);
		const day = dateString.substring(6, 8);

		return `${year}.${month}.${day}`;
	}

	// 텍스트 자르기 함수

	// 텍스트 확장/축소 토글
	function toggleExpandText(reviewId: string): void {
		expandedTexts[reviewId] = !expandedTexts[reviewId];
		expandedTexts = { ...expandedTexts };
	}

	// 리뷰 데이터 로드
	async function loadReviews(currentPage: number = 1, pageSize: number = 20, type: string = 'latest'): Promise<void> {
		try {
			loading = true;
			// Supabase 서비스를 사용하여 리뷰 데이터 가져오기
			const response = await reviewService.getReviewList2({
				page: currentPage,
				size: pageSize,
				type: type,
			});
			
			if (response && response.result && Array.isArray(response.result.rows)) {
				reviews = response.result.rows;
				isNoMoreData = response.result.rows.length !== size;
				console.log(`isNoMoreData: ${isNoMoreData}`);

				// 초기 expandedTexts 세팅
				const initialExpandedState: Record<string, boolean> = {};
				reviews.forEach((review: ReviewItem) => {
					initialExpandedState[review.id] = false;
				});
				expandedTexts = initialExpandedState;
			}
		} catch (error) {
			console.error('리뷰 데이터 로드 실패:', error);
		} finally {
			loading = false;
		}
	}

	// 카테고리에 맞는 배경색 반환

	// 주소를 태그로 변환


	// 장소 상세 페이지로 이동 (팝업 사용 대신 URL 이동 방식으로 변경)
	function goToPlaceDetail(businessId: string): void {
		console.log('장소 상세 페이지로 이동:', businessId);
		
		// 현재 홈 페이지 상태 저장 (상세 페이지로 이동 전)
		saveHomeState();
		
		// 현재 보고 있는 컨텐츠 ID 저장
		try {
			localStorage.setItem('currentViewingContentId', businessId);
			console.log('현재 보는 컨텐츠 ID 저장:', businessId);
		} catch (e) {
			console.error('ID 저장 오류:', e);
		}
		
		// 상태 정보 준비
		const state = { 
			fromHome: true, 
			hasHomeState: true,
			businessId,
			savedAt: new Date().getTime()
		};
		
		// SPA 라우터 사용하여 이동 (state 옵션 사용)
		try {
			goto(`/place/${businessId}`, { state });
			console.log('라우터로 이동 완료, 상태 정보:', state);
		} catch (e) {
			// 오류 발생 시 대체 방법으로 이동
			console.error('라우터 사용 오류:', e);
			location.href = `/place/${businessId}`;
		}
	}

	// 네이버 장소 링크로 이동

	// 추가 리뷰 데이터 로드
	async function loadMoreReviewsData(): Promise<void> {
		try {
			loading = true;
			const response = await reviewService.getReviewList2({
				page: page,
				size: size,
				type: type,
			});

			if (response && response.result && Array.isArray(response.result.rows)) {
				const newReviews = response.result.rows;

				// 새 리뷰에 대한 expandedTexts 세팅
				const newExpandedState: Record<string, boolean> = { ...expandedTexts };
				newReviews.forEach((review: ReviewItem) => {
					newExpandedState[review.id] = false;
				});
				expandedTexts = newExpandedState;

				// 리뷰 데이터 병합
				reviews = [...reviews, ...newReviews];
				isNoMoreData = newReviews.length !== size;
			}
		} catch (error) {
			console.error('추가 리뷰 데이터 로드 실패:', error);
		} finally {
			loading = false;
		}
	}

	// 더 많은 리뷰 로드
	function loadMoreReviews(): void {
		if (loading || isNoMoreData) return;

		page += 1;
		loadMoreReviewsData();
	}

	// 스크롤 이벤트 핸들러
	let isScrollListenerAdded = false;

	function handleScroll(): void {
		if (loading || isNoMoreData) return;

		if (!scrollableArea) return;

		const { scrollTop, scrollHeight, clientHeight } = scrollableArea;

		// 스크롤이 하단에 가까워지면 추가 데이터 로드
		if (scrollTop + clientHeight >= scrollHeight - 300) {
			loadMoreReviews();
		}
	}

	$effect(() => {
		if (scrollableArea && !isScrollListenerAdded) {
			scrollableArea.addEventListener('scroll', handleScroll);
			isScrollListenerAdded = true;
		}
	});

	// 네비게이션 타입 감지 함수
	function detectNavigationType(): { isBackNavigation: boolean; source: string; isDirectNavigation: boolean } {
		// 브라우저 뒤로가기 감지를 위한 여러 기법 적용
		try {
			// 1. Performance API 활용 (가장 신뢰할 수 있는 방법)
			const navigationEntries = window.performance?.getEntriesByType?.('navigation') || [];
			const navigationEntry = navigationEntries[0] as PerformanceNavigationTiming;
			const navigationType = navigationEntry?.type || 'unknown';
			const isBackForward = navigationType === 'back_forward';
			
			// 2. localStorage 플래그 확인 (다른 페이지에서 설정됨)
			const localBackFlag = wasNavigatingBack;
			
			// 3. 현재 history.state 확인
			const currentState = history.state || {};
			const historyBackFlag = currentState.isBackNavigation === true || 
			                        (currentState.fromContentDetail === true) ||
			                        (currentState.fromPlaceDetail === true);
			
			// history.state에서 추가 정보 확인
			const fromDetailPage = currentState.fromContentDetail || currentState.fromPlaceDetail;
			const stateBusinessId = currentState.businessId;
			
			// 4. sessionStorage 플래그 확인
			const sessionBackFlag = sessionStorage.getItem('isBackNavigation') === 'true';
			sessionStorage.removeItem('isBackNavigation');
			
			// 5. Referrer 확인 (이전 페이지 URL 체크)
			const referrer = document.referrer || '';
			const isFromContentDetail = referrer.includes('/place/') || referrer.includes('/content/');
			
			// 6. 새로고침 감지
			const isReload = navigationType === 'reload';
			
			// 7. 직접 접근(URL 입력, 메뉴를 통한 접근) 감지
			const isDirectNavigation = navigationType === 'navigate' && !isFromContentDetail;
			
			// 로깅
			console.log('네비게이션 타입 감지 결과:', {
				isBackForward,
				localBackFlag,
				historyBackFlag,
				sessionBackFlag,
				isFromContentDetail,
				referrer,
				navigationType,
				isReload,
				isDirectNavigation,
				historyState: currentState,
				stateBusinessId
			});
			
			// 각 감지 방법의 결과 종합
			const isBackNavigation = isBackForward || localBackFlag || historyBackFlag || 
									sessionBackFlag || isFromContentDetail;
			
			// 뒤로가기의 출처 식별
			let source = 'unknown';
			if (isBackForward) source = 'performance_api';
			else if (localBackFlag) source = 'localStorage';
			else if (historyBackFlag) source = 'history_state';
			else if (sessionBackFlag) source = 'sessionStorage';
			else if (isFromContentDetail) source = 'referrer';
			else if (isReload) source = 'reload';
			else if (isDirectNavigation) source = 'direct';
			
			// 뒤로가기로 확인되었고 state에 상세 정보가 있는 경우
			if (isBackNavigation && fromDetailPage && stateBusinessId) {
				console.log('상세 페이지에서 뒤로가기로 돌아옴, 컨텐츠 ID:', stateBusinessId);
				// 필요시 여기에 추가 처리 코드 작성
			}
			
			return { isBackNavigation, source, isDirectNavigation };
		} catch (err) {
			console.error('네비게이션 타입 감지 오류:', err);
			return { isBackNavigation: false, source: 'error', isDirectNavigation: true };
		}
	}

	// 컴포넌트 마운트 시 실행
	onMount(() => {
		console.log('onMount: 홈 페이지 로드 시작');
		
		// URL 파라미터에서 탭 ID 읽기
		const urlParams = new URLSearchParams(window.location.search);
		const pathArray = window.location.pathname.split('/');
		const tabIdFromUrl = pathArray.length > 3 && pathArray[2] === 'tab' ? pathArray[3] : null;
		
		// URL의 탭 ID가 있으면 해당 탭으로 설정
		if (tabIdFromUrl) {
			console.log('URL 파라미터에서 탭 ID 감지:', tabIdFromUrl);
			const tabIndex = tabs.findIndex(tab => tab.id === tabIdFromUrl);
			if (tabIndex !== -1) {
				activeTab = tabIndex;
				type = tabs[activeTab].id;
				console.log('탭 인덱스를 URL 파라미터로 설정:', activeTab);
			}
		}
		
		// 네비게이션 타입 감지
		const { isBackNavigation, source, isDirectNavigation } = detectNavigationType();
		console.log(`네비게이션 타입: ${isBackNavigation ? '뒤로가기' : '일반 접근'} (출처: ${source})`);
		
		// 스크롤 매니저 초기화
		const cleanup = scrollManager.initialize();
		
		// 스크롤 컨테이너 요소 설정
		if (scrollableArea) {
			scrollManager.setContainerElement(scrollableArea);
		}
		
		// 스크롤 이벤트 구독
		const unsubscribeScroll = scrollManager.onScroll((scrollPosition) => {
			y = scrollPosition;
			// 스크롤 위치 homeState에 저장
			homeState.scrollPosition = scrollPosition;
		});
		
		// 위로 스크롤 시 헤더 표시
		const unsubscribeScrollUp = scrollManager.onDirectionChange(
			ScrollDirection.UP,
			() => {
				if (!showNav) {
					showNav = true;
				}
			}
		);
		
		// 아래로 스크롤 시 헤더 숨김
		const unsubscribeScrollDown = scrollManager.onDirectionChange(
			ScrollDirection.DOWN,
			() => {
				if (showNav) {
					showNav = false;
				}
			}
		);
		
		// 새로고침 트리거 이벤트 구독
		const unsubscribeRefresh = scrollManager.onRefreshTriggered((position) => {
			refreshMessage = `새로고침 트리거 (${position}px)`;
			console.log('새로고침 트리거:', position);
			
			// 3초 후 메시지 지우기
			setTimeout(() => {
				refreshMessage = '';
			}, 3000);
		});
		
		// 컴포넌트 정리 함수 반환
		return () => {
			// 컴포넌트가 언마운트될 때 상태 저장
			saveHomeState();
			
			cleanup();
			unsubscribeScroll();
			unsubscribeScrollUp();
			unsubscribeScrollDown();
			unsubscribeRefresh();
		};
	});
});
</script>

<script lang="ts">
	import { onMount } from 'svelte';
	import { goto } from '@mateothegreat/svelte5-router';
	import { formatWithCommas } from '$utils/number.util';
	import { ScrollManager, ScrollDirection } from '$lib/utils/ScrollManager';
	import ProfileSidebar from './ProfileSidebar.svelte';
	import Header from './Header.svelte';
	import PlaceDetailPopup from '$lib/components/popup/PlaceDetailPopup.svelte';
	import { detailPopupService } from '$lib/components/popup/DetailPopupService.svelte';
	import Detail from '../place/Detail.svelte';
	import ReviewCard from './components/ReviewCard.svelte';
	import { supabaseReviewService } from '$services/supabase';
	import { reviewService, type ReviewItem } from '$services/review.service';
	import Indicator from '$lib/components/Indicator.svelte';
	import Tabs from '$lib/components/ui/Tabs.svelte';

	// 타입 오류 해결을 위한 타입 선언
	interface ReviewItem {
		id: string;
		business_id: string;
		[key: string]: any;
	}

	// URL 파라미터에서 tabId를 받아오는 부분 추가
	let tabId = $state('');
	
	// props로부터 tabId를 받아옵니다
	let props = $props();
	
	$effect(() => {
		// URL 파라미터에서 tabId 추출
		const pathArray = window.location.pathname.split('/');
		if (pathArray.length > 3 && pathArray[2] === 'tab') {
			tabId = pathArray[3];
		}
	});

	// 브라우저 환경에서만 초기화되는 로컬 상태 변수들
	let wasNavigatingBack = false;
	let lastContentDetailId: string | null = null;
	
	// 브라우저 환경에서만 실행되는 초기화 (SSR 고려)
	if (typeof window !== 'undefined') {
		// 세션스토리지에서 상태 체크 (localStorage 접근 최소화)
		try {
			wasNavigatingBack = sessionStorage.getItem('wasNavigatingBack') === 'true';
			lastContentDetailId = sessionStorage.getItem('currentViewingContentId');
			
			// 사용 후 초기화
			sessionStorage.removeItem('wasNavigatingBack');
			
			if (wasNavigatingBack) {
				console.log('브라우저 뒤로가기 감지: 세션스토리지 플래그 확인됨');
				
				// 마지막으로 본 컨텐츠 ID가 있는지 확인
				if (lastContentDetailId) {
					console.log('마지막으로 본 컨텐츠 ID:', lastContentDetailId);
				}
			}
		} catch (e) {
			console.error('로컬 상태 초기화 오류:', e);
		}
	}

	// 홈 페이지 상태 저장을 위한 객체
	let homeState = $state({
		reviews: [] as ReviewItem[],
		page: 1,
		scrollPosition: 0,
		activeTab: 0,
		type: 'popularity',
		expandedTexts: {} as Record<string, boolean>
	});

	let showNav = $state(true);
	let showSidebar = $state(false);
	let scrollableArea: HTMLDivElement | undefined = $state();
	let y = $state(0);
	let refreshMessage = $state('');
	let isNoMoreData = $state(false);
	// latest,popularity
	let type = $state('popularity');
	
	// 이전 페이지 추적 변수

	// 스크롤 매니저 인스턴스 생성
	const scrollManager = new ScrollManager({
		headerThreshold: 5,
		refreshThreshold: -100,
		debug: false // 개발 중 디버그 모드 활성화
	});
	
	function toggleSidebar(): void {
		console.log('사이드바 토글');
		showSidebar = !showSidebar;
	}
	
	$effect(() => {
		console.log('onMount 실행됨');
		
		// 스크롤 매니저 초기화
		const cleanup = scrollManager.initialize();
		
		// 스크롤 컨테이너 요소 설정
		if (scrollableArea) {
			scrollManager.setContainerElement(scrollableArea);
		}
		
		// 스크롤 이벤트 구독
		const unsubscribeScroll = scrollManager.onScroll((scrollPosition) => {
			y = scrollPosition;
			// 스크롤 위치 homeState에 저장
			homeState.scrollPosition = scrollPosition;
		});
		
		// 위로 스크롤 시 헤더 표시
		const unsubscribeScrollUp = scrollManager.onDirectionChange(
			ScrollDirection.UP,
			() => {
				if (!showNav) {
					showNav = true;
				}
			}
		);
		
		// 아래로 스크롤 시 헤더 숨김
		const unsubscribeScrollDown = scrollManager.onDirectionChange(
			ScrollDirection.DOWN,
			() => {
				if (showNav) {
					showNav = false;
				}
			}
		);
		
		// 새로고침 트리거 이벤트 구독
		const unsubscribeRefresh = scrollManager.onRefreshTriggered((position) => {
			refreshMessage = `새로고침 트리거 (${position}px)`;
			console.log('새로고침 트리거:', position);
			
			// 3초 후 메시지 지우기
			setTimeout(() => {
				refreshMessage = '';
			}, 3000);
		});
		
		// 컴포넌트 정리 함수 반환
		return () => {
			// 컴포넌트가 언마운트될 때 상태 저장
			saveHomeState();
			
			cleanup();
			unsubscribeScroll();
			unsubscribeScrollUp();
			unsubscribeScrollDown();
			unsubscribeRefresh();
		};
	});

	// 상태 관리
	let loading = $state(true);
	let reviews: ReviewItem[] = $state([]);
	let page = $state(1);
	let size = $state(20);
	let expandedTexts = $state<Record<string, boolean>>({});
	let activeTab = $state(0); // 활성 탭 인덱스 추가

	// 탭 정보
	const tabs = [
  { id: 'popularity', label: '인기', desc: '최근 3개월 동안 많은 사람들의 관심을 받은 리뷰를 모아 보여드려요.', emoji: '', view:'mv_place_review_popularity_for_3m_10k' },
  { id: 'hidden_gem', label: '발견', desc: '아직 많이 알려지지 않았지만, 품질 좋은 리뷰로 뽑힌 맛집을 찾아드려요.', emoji: '', view:'mv_place_review_hidden_gem_for_10k' },
//   { id: 'seasonal', label: '시즌', desc: '지금 계절에 딱 어울리는, 최근 2년간 계절별 인기 리뷰를 소개합니다.', emoji: '', view:'mv_place_review_seasonal_for_2y_10k' },
  { id: 'visit_count', label: '단골', desc: '여러 번 방문한 단골들이 남긴 신뢰도 높은 리뷰만 모아서 보여드려요.', emoji: '', view:'mv_place_review_regular_customer_for_10k' },
  { id: 'latest', label: '최신', desc: '가장 최근에 등록된 따끈한 리뷰들을 모았어요. 최신 트렌드를 놓치지 마세요.', emoji: '', view:'mv_place_review_popularity_for_3m_10k' },
  { id: 'my_liked', label: '좋아요', desc: '내가 "좋아요"를 누른 리뷰만 모아서 한 번에 볼 수 있도록 보여드려요.', emoji: '', view:'mv_place_review_my_liked_for_10k' },
]

	// 홈 페이지 상태 저장 함수
	function saveHomeState() {
		homeState = {
			reviews,
			page,
			scrollPosition: y,
			activeTab,
			type,
			expandedTexts
		};
		
		console.log('홈 페이지 상태 저장');
		
		try {
			// 상태 저장 시 타임스탬프와 함께 저장 (나중에 상태의 신선도 확인용)
			const stateWithMeta = {
				data: homeState,
				timestamp: new Date().getTime(),
				source: 'homePageState'
			};
			
			// 세션스토리지만 사용 (모바일 성능 최적화)
			sessionStorage.setItem('homeUIState', JSON.stringify(stateWithMeta));
			
			console.log('홈 상태 저장 완료');
		} catch (error) {
			console.error('상태 저장 실패:', error);
		}
	}
	
	// 홈 페이지 상태 복원 함수
	function restoreHomeState() {
		try {
			// 세션스토리지에서만 시도 (localStorage 접근 제거)
			const savedStateJson = sessionStorage.getItem('homeUIState');
			
			if (!savedStateJson) {
				console.log('저장된 상태 없음: 새로운 데이터 로드 필요');
				return false;
			}
			
			console.log('저장된 상태 발견');
			
			const savedStateMeta = JSON.parse(savedStateJson);
			const parsedState = savedStateMeta.data;
			const timestamp = savedStateMeta.timestamp;
			
			// 타임스탬프 확인 (5분 이상 지난 데이터는 신선하지 않은 것으로 간주 - 시간 단축)
			const now = new Date().getTime();
			const isStale = now - timestamp > 5 * 60 * 1000; // 5분
			
			if (isStale) {
				console.log('저장된 상태가 오래됨 (5분 초과)');
				sessionStorage.removeItem('homeUIState');
				return false;
			}
			
			console.log('저장된 상태 복원 중');
			
			// 필요한 상태들 복원
			reviews = parsedState.reviews || [];
			page = parsedState.page || 1;
			activeTab = parsedState.activeTab ?? 0;
			type = parsedState.type || 'popularity';
			expandedTexts = parsedState.expandedTexts || {};
			
			// 스크롤 위치 복원
			if (scrollableArea && parsedState.scrollPosition) {
				console.log('스크롤 위치 복원 예정:', parsedState.scrollPosition);
				// RAF를 사용하여 DOM 업데이트 후 스크롤 적용 (setTimeout 추가로 안정성 향상)
				setTimeout(() => {
					requestAnimationFrame(() => {
						if (scrollableArea) {
							console.log('스크롤 위치 복원 실행');
							scrollableArea.scrollTop = parsedState.scrollPosition;
						}
					});
				}, 0);
			}
			
			// 복원 후 상태 제거 (중요: 일회성 사용 보장)
			sessionStorage.removeItem('homeUIState');
			console.log('저장된 상태 복원 및 삭제 완료');
			
			return true;
		} catch (error) {
			console.error('상태 복원 실패:', error);
			sessionStorage.removeItem('homeUIState');
		}
		
		return false;
	}

	// 탭 변경 함수
	function handleTabChange(index: number) {
		activeTab = index;
		type = tabs[activeTab].id;
		page = 1;
		reviews = [];
		isNoMoreData = false;
		loadReviews(page, size, type);
		
		// URL 변경
		goto(`/home/tab/${tabs[activeTab].id}`, { replace: true });
		
		// 스크롤을 맨 위로 이동
		scrollManager.scrollToTop('auto');
	}

	// 날짜 포맷팅 함수
	function formatDate(dateString: string): string {
		if (!dateString) return '';

		const year = dateString.substring(0, 4);
		const month = dateString.substring(4, 6);
		const day = dateString.substring(6, 8);

		return `${year}.${month}.${day}`;
	}

	// 텍스트 자르기 함수

	// 텍스트 확장/축소 토글
	function toggleExpandText(reviewId: string): void {
		expandedTexts[reviewId] = !expandedTexts[reviewId];
		expandedTexts = { ...expandedTexts };
	}

	// 리뷰 데이터 로드
	async function loadReviews(currentPage: number = 1, pageSize: number = 20, type: string = 'latest'): Promise<void> {
		try {
			loading = true;
			// Supabase 서비스를 사용하여 리뷰 데이터 가져오기
			const response = await reviewService.getReviewList2({
				page: currentPage,
				size: pageSize,
				type: type,
			});
			
			if (response && response.result && Array.isArray(response.result.rows)) {
				reviews = response.result.rows;
				isNoMoreData = response.result.rows.length !== size;
				console.log(`isNoMoreData: ${isNoMoreData}`);

				// 초기 expandedTexts 세팅
				const initialExpandedState: Record<string, boolean> = {};
				reviews.forEach((review: ReviewItem) => {
					initialExpandedState[review.id] = false;
				});
				expandedTexts = initialExpandedState;
			}
		} catch (error) {
			console.error('리뷰 데이터 로드 실패:', error);
		} finally {
			loading = false;
		}
	}

	// 카테고리에 맞는 배경색 반환

	// 주소를 태그로 변환


	// 장소 상세 페이지로 이동 (팝업 사용 대신 URL 이동 방식으로 변경)
	function goToPlaceDetail(businessId: string): void {
		console.log('장소 상세 페이지로 이동:', businessId);
		
		// 현재 홈 페이지 상태 저장 (상세 페이지로 이동 전)
		saveHomeState();
		
		// 현재 보고 있는 컨텐츠 ID 저장
		try {
			localStorage.setItem('currentViewingContentId', businessId);
			console.log('현재 보는 컨텐츠 ID 저장:', businessId);
		} catch (e) {
			console.error('ID 저장 오류:', e);
		}
		
		// 상태 정보 준비
		const state = { 
			fromHome: true, 
			hasHomeState: true,
			businessId,
			savedAt: new Date().getTime()
		};
		
		// SPA 라우터 사용하여 이동 (state 옵션 사용)
		try {
			goto(`/place/${businessId}`, { state });
			console.log('라우터로 이동 완료, 상태 정보:', state);
		} catch (e) {
			// 오류 발생 시 대체 방법으로 이동
			console.error('라우터 사용 오류:', e);
			location.href = `/place/${businessId}`;
		}
	}

	// 네이버 장소 링크로 이동

	// 추가 리뷰 데이터 로드
	async function loadMoreReviewsData(): Promise<void> {
		try {
			loading = true;
			const response = await reviewService.getReviewList2({
				page: page,
				size: size,
				type: type,
			});

			if (response && response.result && Array.isArray(response.result.rows)) {
				const newReviews = response.result.rows;

				// 새 리뷰에 대한 expandedTexts 세팅
				const newExpandedState: Record<string, boolean> = { ...expandedTexts };
				newReviews.forEach((review: ReviewItem) => {
					newExpandedState[review.id] = false;
				});
				expandedTexts = newExpandedState;

				// 리뷰 데이터 병합
				reviews = [...reviews, ...newReviews];
				isNoMoreData = newReviews.length !== size;
			}
		} catch (error) {
			console.error('추가 리뷰 데이터 로드 실패:', error);
		} finally {
			loading = false;
		}
	}

	// 더 많은 리뷰 로드
	function loadMoreReviews(): void {
		if (loading || isNoMoreData) return;

		page += 1;
		loadMoreReviewsData();
	}

	// 스크롤 이벤트 핸들러
	let isScrollListenerAdded = false;

	function handleScroll(): void {
		if (loading || isNoMoreData) return;

		if (!scrollableArea) return;

		const { scrollTop, scrollHeight, clientHeight } = scrollableArea;

		// 스크롤이 하단에 가까워지면 추가 데이터 로드
		if (scrollTop + clientHeight >= scrollHeight - 300) {
			loadMoreReviews();
		}
	}

	$effect(() => {
		if (scrollableArea && !isScrollListenerAdded) {
			scrollableArea.addEventListener('scroll', handleScroll);
			isScrollListenerAdded = true;
		}
	});

	// 네비게이션 타입 감지 함수
	function detectNavigationType(): { isBackNavigation: boolean; source: string; isDirectNavigation: boolean } {
		// 브라우저 뒤로가기 감지를 위한 여러 기법 적용
		try {
			// 1. Performance API 활용 (가장 신뢰할 수 있는 방법)
			const navigationEntries = window.performance?.getEntriesByType?.('navigation') || [];
			const navigationEntry = navigationEntries[0] as PerformanceNavigationTiming;
			const navigationType = navigationEntry?.type || 'unknown';
			const isBackForward = navigationType === 'back_forward';
			
			// 2. localStorage 플래그 확인 (다른 페이지에서 설정됨)
			const localBackFlag = wasNavigatingBack;
			
			// 3. 현재 history.state 확인
			const currentState = history.state || {};
			const historyBackFlag = currentState.isBackNavigation === true || 
			                        (currentState.fromContentDetail === true) ||
			                        (currentState.fromPlaceDetail === true);
			
			// history.state에서 추가 정보 확인
			const fromDetailPage = currentState.fromContentDetail || currentState.fromPlaceDetail;
			const stateBusinessId = currentState.businessId;
			
			// 4. sessionStorage 플래그 확인
			const sessionBackFlag = sessionStorage.getItem('isBackNavigation') === 'true';
			sessionStorage.removeItem('isBackNavigation');
			
			// 5. Referrer 확인 (이전 페이지 URL 체크)
			const referrer = document.referrer || '';
			const isFromContentDetail = referrer.includes('/place/') || referrer.includes('/content/');
			
			// 6. 새로고침 감지
			const isReload = navigationType === 'reload';
			
			// 7. 직접 접근(URL 입력, 메뉴를 통한 접근) 감지
			const isDirectNavigation = navigationType === 'navigate' && !isFromContentDetail;
			
			// 로깅
			console.log('네비게이션 타입 감지 결과:', {
				isBackForward,
				localBackFlag,
				historyBackFlag,
				sessionBackFlag,
				isFromContentDetail,
				referrer,
				navigationType,
				isReload,
				isDirectNavigation,
				historyState: currentState,
				stateBusinessId
			});
			
			// 각 감지 방법의 결과 종합
			const isBackNavigation = isBackForward || localBackFlag || historyBackFlag || 
									sessionBackFlag || isFromContentDetail;
			
			// 뒤로가기의 출처 식별
			let source = 'unknown';
			if (isBackForward) source = 'performance_api';
			else if (localBackFlag) source = 'localStorage';
			else if (historyBackFlag) source = 'history_state';
			else if (sessionBackFlag) source = 'sessionStorage';
			else if (isFromContentDetail) source = 'referrer';
			else if (isReload) source = 'reload';
			else if (isDirectNavigation) source = 'direct';
			
			// 뒤로가기로 확인되었고 state에 상세 정보가 있는 경우
			if (isBackNavigation && fromDetailPage && stateBusinessId) {
				console.log('상세 페이지에서 뒤로가기로 돌아옴, 컨텐츠 ID:', stateBusinessId);
				// 필요시 여기에 추가 처리 코드 작성
			}
			
			return { isBackNavigation, source, isDirectNavigation };
		} catch (err) {
			console.error('네비게이션 타입 감지 오류:', err);
			return { isBackNavigation: false, source: 'error', isDirectNavigation: true };
		}
	}

	// 컴포넌트 마운트 시 실행
	onMount(() => {
		console.log('onMount: 홈 페이지 로드 시작');
		
		// URL 파라미터에서 탭 ID 읽기
		const urlParams = new URLSearchParams(window.location.search);
		const pathArray = window.location.pathname.split('/');
		const tabIdFromUrl = pathArray.length > 3 && pathArray[2] === 'tab' ? pathArray[3] : null;
		
		// URL의 탭 ID가 있으면 해당 탭으로 설정
		if (tabIdFromUrl) {
			console.log('URL 파라미터에서 탭 ID 감지:', tabIdFromUrl);
			const tabIndex = tabs.findIndex(tab => tab.id === tabIdFromUrl);
			if (tabIndex !== -1) {
				activeTab = tabIndex;
				type = tabs[activeTab].id;
				console.log('탭 인덱스를 URL 파라미터로 설정:', activeTab);
			}
		}
		
		// 네비게이션 타입 감지
		const { isBackNavigation, source, isDirectNavigation } = detectNavigationType();
		console.log(`네비게이션 타입: ${isBackNavigation ? '뒤로가기' : '일반 접근'} (출처: ${source})`);
		
		// 스크롤 매니저 초기화
		const cleanup = scrollManager.initialize();
		
		// 스크롤 컨테이너 요소 설정
		if (scrollableArea) {
			scrollManager.setContainerElement(scrollableArea);
		}
		
		// 스크롤 이벤트 구독
		const unsubscribeScroll = scrollManager.onScroll((scrollPosition) => {
			y = scrollPosition;
			// 스크롤 위치 homeState에 저장
			homeState.scrollPosition = scrollPosition;
		});
		
		// 위로 스크롤 시 헤더 표시
		const unsubscribeScrollUp = scrollManager.onDirectionChange(
			ScrollDirection.UP,
			() => {
				if (!showNav) {
					showNav = true;
				}
			}
		);
		
		// 아래로 스크롤 시 헤더 숨김
		const unsubscribeScrollDown = scrollManager.onDirectionChange(
			ScrollDirection.DOWN,
			() => {
				if (showNav) {
					showNav = false;
				}
			}
		);
		
		// 새로고침 트리거 이벤트 구독
		const unsubscribeRefresh = scrollManager.onRefreshTriggered((position) => {
			refreshMessage = `새로고침 트리거 (${position}px)`;
			console.log('새로고침 트리거:', position);
			
			// 3초 후 메시지 지우기
			setTimeout(() => {
				refreshMessage = '';
			}, 3000);
		});
		
		// 컴포넌트 정리 함수 반환
		return () => {
			// 컴포넌트가 언마운트될 때 상태 저장
			saveHomeState();
			
			cleanup();
			unsubscribeScroll();
			unsubscribeScrollUp();
			unsubscribeScrollDown();
			unsubscribeRefresh();
		};
	});
});
</script>

<script lang="ts">
	import { onMount } from 'svelte';
	import { goto } from '@mateothegreat/svelte5-router';
	import { formatWithCommas } from '$utils/number.util';
	import { ScrollManager, ScrollDirection } from '$lib/utils/ScrollManager';
	import ProfileSidebar from './ProfileSidebar.svelte';
	import Header from './Header.svelte';
	import PlaceDetailPopup from '$lib/components/popup/PlaceDetailPopup.svelte';
	import { detailPopupService } from '$lib/components/popup/DetailPopupService.svelte';
	import Detail from '../place/Detail.svelte';
	import ReviewCard from './components/ReviewCard.svelte';
	import { supabaseReviewService } from '$services/supabase';
	import { reviewService, type ReviewItem } from '$services/review.service';
	import Indicator from '$lib/components/Indicator.svelte';
	import Tabs from '$lib/components/ui/Tabs.svelte';

	// 타입 오류 해결을 위한 타입 선언
	interface ReviewItem {
		id: string;
		business_id: string;
		[key: string]: any;
	}

	// URL 파라미터에서 tabId를 받아오는 부분 추가
	let tabId = $state('');
	
	// props로부터 tabId를 받아옵니다
	let props = $props();
	
	$effect(() => {
		// URL 파라미터에서 tabId 추출
		const pathArray = window.location.pathname.split('/');
		if (pathArray.length > 3 && pathArray[2] === 'tab') {
			tabId = pathArray[3];
		}
	});

	// 브라우저 환경에서만 초기화되는 로컬 상태 변수들
	let wasNavigatingBack = false;
	let lastContentDetailId: string | null = null;
	
	// 브라우저 환경에서만 실행되는 초기화 (SSR 고려)
	if (typeof window !== 'undefined') {
		// 세션스토리지에서 상태 체크 (localStorage 접근 최소화)
		try {
			wasNavigatingBack = sessionStorage.getItem('wasNavigatingBack') === 'true';
			lastContentDetailId = sessionStorage.getItem('currentViewingContentId');
			
			// 사용 후 초기화
			sessionStorage.removeItem('wasNavigatingBack');
			
			if (wasNavigatingBack) {
				console.log('브라우저 뒤로가기 감지: 세션스토리지 플래그 확인됨');
				
				// 마지막으로 본 컨텐츠 ID가 있는지 확인
				if (lastContentDetailId) {
					console.log('마지막으로 본 컨텐츠 ID:', lastContentDetailId);
				}
			}
		} catch (e) {
			console.error('로컬 상태 초기화 오류:', e);
		}
	}

	// 홈 페이지 상태 저장을 위한 객체
	let homeState = $state({
		reviews: [] as ReviewItem[],
		page: 1,
		scrollPosition: 0,
		activeTab: 0,
		type: 'popularity',
		expandedTexts: {} as Record<string, boolean>
	});

	let showNav = $state(true);
	let showSidebar = $state(false);
	let scrollableArea: HTMLDivElement | undefined = $state();
	let y = $state(0);
	let refreshMessage = $state('');
	let isNoMoreData = $state(false);
	// latest,popularity
	let type = $state('popularity');
	
	// 이전 페이지 추적 변수

	// 스크롤 매니저 인스턴스 생성
	const scrollManager = new ScrollManager({
		headerThreshold: 5,
		refreshThreshold: -100,
		debug: false // 개발 중 디버그 모드 활성화
	});
	
	function toggleSidebar(): void {
		console.log('사이드바 토글');
		showSidebar = !showSidebar;
	}
	
	$effect(() => {
		console.log('onMount 실행됨');
		
		// 스크롤 매니저 초기화
		const cleanup = scrollManager.initialize();
		
		// 스크롤 컨테이너 요소 설정
		if (scrollableArea) {
			scrollManager.setContainerElement(scrollableArea);
		}
		
		// 스크롤 이벤트 구독
		const unsubscribeScroll = scrollManager.onScroll((scrollPosition) => {
			y = scrollPosition;
			// 스크롤 위치 homeState에 저장
			homeState.scrollPosition = scrollPosition;
		});
		
		// 위로 스크롤 시 헤더 표시
		const unsubscribeScrollUp = scrollManager.onDirectionChange(
			ScrollDirection.UP,
			() => {
				if (!showNav) {
					showNav = true;
				}
			}
		);
		
		// 아래로 스크롤 시 헤더 숨김
		const unsubscribeScrollDown = scrollManager.onDirectionChange(
			ScrollDirection.DOWN,
			() => {
				if (showNav) {
					showNav = false;
				}
			}
		);
		
		// 새로고침 트리거 이벤트 구독
		const unsubscribeRefresh = scrollManager.onRefreshTriggered((position) => {
			refreshMessage = `새로고침 트리거 (${position}px)`;
			console.log('새로고침 트리거:', position);
			
			// 3초 후 메시지 지우기
			setTimeout(() => {
				refreshMessage = '';
			}, 3000);
		});
		
		// 컴포넌트 정리 함수 반환
		return () => {
			// 컴포넌트가 언마운트될 때 상태 저장
			saveHomeState();
			
			cleanup();
			unsubscribeScroll();
			unsubscribeScrollUp();
			unsubscribeScrollDown();
			unsubscribeRefresh();
		};
	});

	// 상태 관리
	let loading = $state(true);
	let reviews: ReviewItem[] = $state([]);
	let page = $state(1);
	let size = $state(20);
	let expandedTexts = $state<Record<string, boolean>>({});
	let activeTab = $state(0); // 활성 탭 인덱스 추가

	// 탭 정보
	const tabs = [
  { id: 'popularity', label: '인기', desc: '최근 3개월 동안 많은 사람들의 관심을 받은 리뷰를 모아 보여드려요.', emoji: '', view:'mv_place_review_popularity_for_3m_10k' },
  { id: 'hidden_gem', label: '발견', desc: '아직 많이 알려지지 않았지만, 품질 좋은 리뷰로 뽑힌 맛집을 찾아드려요.', emoji: '', view:'mv_place_review_hidden_gem_for_10k' },
//   { id: 'seasonal', label: '시즌', desc: '지금 계절에 딱 어울리는, 최근 2년간 계절별 인기 리뷰를 소개합니다.', emoji: '', view:'mv_place_review_seasonal_for_2y_10k' },
  { id: 'visit_count', label: '단골', desc: '여러 번 방문한 단골들이 남긴 신뢰도 높은 리뷰만 모아서 보여드려요.', emoji: '', view:'mv_place_review_regular_customer_for_10k' },
  { id: 'latest', label: '최신', desc: '가장 최근에 등록된 따끈한 리뷰들을 모았어요. 최신 트렌드를 놓치지 마세요.', emoji: '', view:'mv_place_review_popularity_for_3m_10k' },
  { id: 'my_liked', label: '좋아요', desc: '내가 "좋아요"를 누른 리뷰만 모아서 한 번에 볼 수 있도록 보여드려요.', emoji: '', view:'mv_place_review_my_liked_for_10k' },
]

	// 홈 페이지 상태 저장 함수
	function saveHomeState() {
		homeState = {
			reviews,
			page,
			scrollPosition: y,
			activeTab,
			type,
			expandedTexts
		};
		
		console.log('홈 페이지 상태 저장');
		
		try {
			// 상태 저장 시 타임스탬프와 함께 저장 (나중에 상태의 신선도 확인용)
			const stateWithMeta = {
				data: homeState,
				timestamp: new Date().getTime(),
				source: 'homePageState'
			};
			
			// 세션스토리지만 사용 (모바일 성능 최적화)
			sessionStorage.setItem('homeUIState', JSON.stringify(stateWithMeta));
			
			console.log('홈 상태 저장 완료');
		} catch (error) {
			console.error('상태 저장 실패:', error);
		}
	}
	
	// 홈 페이지 상태 복원 함수
	function restoreHomeState() {
		try {
			// 세션스토리지에서만 시도 (localStorage 접근 제거)
			const savedStateJson = sessionStorage.getItem('homeUIState');
			
			if (!savedStateJson) {
				console.log('저장된 상태 없음: 새로운 데이터 로드 필요');
				return false;
			}
			
			console.log('저장된 상태 발견');
			
			const savedStateMeta = JSON.parse(savedStateJson);
			const parsedState = savedStateMeta.data;
			const timestamp = savedStateMeta.timestamp;
			
			// 타임스탬프 확인 (5분 이상 지난 데이터는 신선하지 않은 것으로 간주 - 시간 단축)
			const now = new Date().getTime();
			const isStale = now - timestamp > 5 * 60 * 1000; // 5분
			
			if (isStale) {
				console.log('저장된 상태가 오래됨 (5분 초과)');
				sessionStorage.removeItem('homeUIState');
				return false;
			}
			
			console.log('저장된 상태 복원 중');
			
			// 필요한 상태들 복원
			reviews = parsedState.reviews || [];
			page = parsedState.page || 1;
			activeTab = parsedState.activeTab ?? 0;
			type = parsedState.type || 'popularity';
			expandedTexts = parsedState.expandedTexts || {};
			
			// 스크롤 위치 복원
			if (scrollableArea && parsedState.scrollPosition) {
				console.log('스크롤 위치 복원 예정:', parsedState.scrollPosition);
				// RAF를 사용하여 DOM 업데이트 후 스크롤 적용 (setTimeout 추가로 안정성 향상)
				setTimeout(() => {
					requestAnimationFrame(() => {
						if (scrollableArea) {
							console.log('스크롤 위치 복원 실행');
							scrollableArea.scrollTop = parsedState.scrollPosition;
						}
					});
				}, 0);
			}
			
			// 복원 후 상태 제거 (중요: 일회성 사용 보장)
			sessionStorage.removeItem('homeUIState');
			console.log('저장된 상태 복원 및 삭제 