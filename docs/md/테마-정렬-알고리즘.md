# 테마 정렬 알고리즘 (Harmony Score)

다중 테마 검색 시, 단순히 첫 번째 테마의 점수만으로 정렬하는 것이 아니라 선택된 모든 테마의 일치도와 강도를 종합적으로 반영하여 정렬합니다.

## 1. 정렬 콘셉트 (Integrated Harmony Score)

사용자가 여러 개의 테마를 선택했을 때, **"얼마나 많은 테마가 일치하는가(Coverage)"**와 **"각 테마의 투표 수가 얼마나 많은가(Strength)"**를 동시에 고려합니다.

### 주요 요소
1. **Match Coverage (일치 범위)**: 사용자가 선택한 $N$개의 테마 중 해당 장소가 몇 개나 일치하는가?
2. **Aggregate Strength (총합 강도)**: 일치하는 테마들의 투표 수(`count`) 총합입니다.
3. **Positional Weighting (가중치 반영)**: 사용자가 먼저 선택한 테마(배열의 앞순서)에 더 높은 가중치를 부여합니다.

## 2. 점수 계산 공식

$$HarmonyScore = (MatchingCount \times 1,000,000) + \sum_{i=1}^{N} \left( \text{Count}_{i} \times \frac{1}{\text{Position}_{i}} \right)$$

- **MatchingCount**: 장소가 보유한 테마 중 사용자가 선택한 테마와 일치하는 개수입니다. 1,000,000을 곱하여 일치 개수가 많은 장소가 무조건 상단에 오도록 합니다.
- **Count**: 해당 테마에 대한 방문자 리뷰 투표 수입니다.
- **Position**: 사용자가 선택한 테마 배열에서의 인덱스(1부터 시작)입니다. 첫 번째 테마는 100%, 두 번째는 50%, 세 번째는 33%... 식으로 가중치가 줄어듭니다.

## 3. 성능 최적화 (V5.1)

대규모 데이터셋(예: 서울시 전체 장소 16만 건)에서 테마 정렬 시 발생하는 5초 타임아웃 문제를 해결하기 위해 다단계 최적화가 적용되었습니다.

### 3.1 병목 원인 분석

| 단계 | 문제점 | 소요 시간 |
|------|--------|----------|
| 지역 필터링 | "서울" 16만 건 전체 스캔 후 `is_franchise` 필터 | 9.6초 |
| 테마 조인 | 1만 건 × MV 개별 조인 (Nested Loop) | 5.4초 |
| **총합** | | **15초 (타임아웃)** |

### 3.2 해결 전략

#### 1) Partial Index 도입 (핵심)
`is_franchise = FALSE` 조건이 기존 인덱스에 포함되지 않아 전체 스캔이 발생했습니다. **Partial Index**를 추가하여 비프랜차이즈 장소만 인덱싱합니다.

```sql
CREATE INDEX idx_place_group_reviews_no_franchise 
ON public.tbl_place (group1, visitor_reviews_total DESC NULLS LAST)
WHERE is_franchise = FALSE;
```

- **효과**: 지역 필터링 9.6초 → **0.1초** (96배 개선)

#### 2) 테마 필터 조기 적용 (Early Filtering)
후보군 추출 시점에 테마 존재 여부를 `EXISTS` 서브쿼리로 즉시 확인하여, 테마가 없는 장소는 애초에 후보군에서 제외합니다.

```sql
-- 기존: 서울 전체(16만) → 상위 1만 → 테마 필터
-- 개선: 서울 중 테마 있는 장소만 → 상위 1만
WHERE p.group1 = '서울' AND p.is_franchise = FALSE
  AND EXISTS (
    SELECT 1 FROM mv_place_theme_scores ts 
    WHERE ts.place_id = p.id 
      AND ts.theme_code = ANY(ARRAY['parking_easy','price_worthy'])
  )
```

#### 3) MV 복합 인덱스 추가
`mv_place_theme_scores`에 `(theme_code, place_id)` 복합 인덱스를 추가하여 테마 검색 속도를 최적화합니다.

```sql
CREATE INDEX idx_mv_theme_code_place_id 
ON public.mv_place_theme_scores (theme_code, place_id);
```

### 3.3 최적화 결과

| 단계 | 개선 전 | 개선 후 |
|------|--------|--------|
| 지역 필터링 | 9.6초 | **0.1초** |
| 테마 조인 | 5.4초 | **1.2초** |
| **총합** | **15초** | **1.3초** |

## 4. SQL 구현 (V5.1)

```sql
WITH base_candidates AS (
    -- 1단계: Partial Index + EXISTS로 후보군 조기 선정
    SELECT p.id, p.visitor_reviews_total, p.visitor_reviews_score
    FROM public.tbl_place p
    WHERE p.group1 = $group1 
      AND p.is_franchise = FALSE
      AND EXISTS (
        SELECT 1 FROM mv_place_theme_scores ts_filter 
        WHERE ts_filter.place_id = p.id 
          AND ts_filter.theme_code = ANY($theme_codes)
      )
    ORDER BY p.visitor_reviews_total DESC NULLS LAST
    LIMIT 10000
),
theme_matches AS (
    -- 2단계: 후보군에 대해서만 Harmony Score 계산
    SELECT 
        ts.place_id,
        (COUNT(*) * 1000000 + SUM(ts.count * (1.0 / array_position($theme_codes, ts.theme_code))))::NUMERIC AS harmony_score
    FROM mv_place_theme_scores ts
    JOIN base_candidates bc ON ts.place_id = bc.id
    WHERE ts.theme_code = ANY($theme_codes)
    GROUP BY ts.place_id
),
scored_places AS (
    -- 3단계: Harmony Score로 정렬 후 페이징
    SELECT bc.id, tm.harmony_score, ...
    FROM base_candidates bc
    JOIN theme_matches tm ON bc.id = tm.place_id
    ORDER BY harmony_score DESC NULLS LAST, visitor_reviews_total DESC NULLS LAST
    LIMIT 21 OFFSET 0
)
-- 4단계: 최종 결과셋에 대해서만 무거운 함수 실행 (Late Joining)
SELECT jsonb_build_object(..., 'interaction', v1_common_place_interaction(p.id), ...)
FROM scored_places s
JOIN tbl_place p ON s.id = p.id;
```

## 5. 필수 인덱스 목록

| 테이블 | 인덱스명 | 정의 |
|--------|---------|------|
| `tbl_place` | `idx_place_group_reviews_no_franchise` | `(group1, visitor_reviews_total DESC) WHERE is_franchise = FALSE` |
| `mv_place_theme_scores` | `idx_mv_theme_code` | `(theme_code)` |
| `mv_place_theme_scores` | `idx_mv_theme_place_id` | `(place_id)` |
| `mv_place_theme_scores` | `idx_mv_theme_code_place_id` | `(theme_code, place_id)` |

## 6. 기대 효과

- **타임아웃 해결**: 5초 타임아웃 환경에서도 서울 등 대규모 지역 검색 시 **1.3초 내외**의 빠른 응답 보장
- **품질 보장**: 리뷰 수 기반으로 후보군을 선정하므로, 테마가 일치하면서도 신뢰도가 높은 장소가 우선 추천
- **확장성**: Partial Index와 복합 인덱스를 통해 데이터 증가에도 안정적인 성능 유지
